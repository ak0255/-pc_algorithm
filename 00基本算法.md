# 00基本算法

***AcWing***

### 1、位运算

**快速幂**

求 *a* 的 *b* 次方对 *p* 取模的值。

> **数据范围**
>
> 0≤*a*,*b*≤109
>
>  1≤*p*≤109

```cpp
while (b)
{
    if (b & 1)
        ans = (ans * a) % p;
    a = (a * a) % p;
    b >>= 1;
}
cout << ans % p;
```

**64位乘法**

求 *a* 乘 *b* 对 *p* 取模的值。

> 数据范围
>
> 1≤*a*,*b*,*p*≤1018

```cpp
while(b){
        if(b&1)
            ans=(ans+a)%p;
        a=(2*a)%p;
        b>>=1;
    }
```

**约数之和**

n的(a1+1)(a2+1)⋅⋅⋅(ak+1)个正约数
180=2^2∗3^2∗5^1
约数个数：(2+1)(2+1)(1+1)=18
约数和：(1+2+4)(1+3+9)(1+5)=546

**四阶汉罗塔**

```cpp
a[1]=1,b[1]=1,a[2]=3,b[2]=3;
for(register int i=3;i<=12;++i)//三阶汉罗塔
{
    b[i]=2*b[i-1]+1;
}
for(register int i=3;i<=12;++i)//四阶汉罗塔
{
    a[i]=0x7fffff;
    for(register int j=1;j<i;++j)
    {
        a[i]=min(2*a[j]+b[i-j],a[i]);
    }
}
```

**前缀和、差分**

```cpp
int a[N];//原数组
int s[N];//前缀和
int c[N];//差分
for(int i = 1;i <= n;i++){
    cin >> a[i];
    s[i] = s[i - 1] + a[i];
    c[i] = a[i] - a[i - 1];
}
//差分数组的前缀和是原数组，前缀和的差分是原数组
```

**超快速排序**

递归排序求逆序数

```cpp
#include <iostream>
#define INF 0xFFFFFF
using namespace std;

typedef long long ll;
const int N = 5e5 + 10;
ll que[N], ans = 0;

void Merge(int l, int mid, int r)
{
    int len1 = mid - l + 1;//左边的长度
    int len2 = r - mid;//右边的长度
    int L[len1 + 2], R[len2 + 2];//构造数组临时存放
    for (int i = 1; i <= len1; i++)
        L[i] = que[l + i - 1];
    for (int i = 1; i <= len2; i++)
        R[i] = que[mid + i];
    L[len1 + 1] = 0xfffffff;//防止越界
    R[len2 + 1] = 0xfffffff;//防止越界
    int left = 1, right = 1;
    for (int i = l; i <= r; i++)//排序
    {
        if (L[left] <= R[right])
            que[i] = L[left++];
        else
        {
            que[i] = R[right++];
            ans += len1 - left + 1;//顺便求逆序数
        }
    }
}

void mergeSort(int l, int r)//分治
{
    if (l < r)
    {
        int mid = l + r >> 1;
        mergeSort(l, mid);//递归先排左边
        mergeSort(mid + 1, r);//再排右边
        Merge(l, mid, r);//合并两个有序数组
    }
}

int main()
{
    // freopen("in.txt", "r", stdin);
    // freopen("out.txt", "w", stdout);
    // ios;
    ll n;
    while (cin >> n, n)
    {
        ans = 0;
        for (int i = 1; i <= n; i++)
            cin >> que[i];
        mergeSort(1, n);
        cout << ans << endl;
    }
    return 0;
}

```

**环形排序问题**

```cpp
ll pd(int que[], int n)
{
    int ans = 0;
    for (register int i = 1; i <= n; i++)
    {
        que[i] -= que[0] / n;//算出每一列变成完美的代价
        f[i] = f[i - 1] + que[i];//求出前缀和
    }
    sort(f + 1, f + n + 1);//排序
    for (register int i = 1; i <= n; i++)
    {
        ans += abs(f[i] - f[(n + 1) >> 1]);//每个点的代价就是在前缀和数组中和排完序处在中间的差值
    }
    return ans;
}
```





































