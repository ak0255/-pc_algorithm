

| 模板                       | 快捷键            |
| -------------------------- | ----------------- |
| 标准库万能头               | `#incl`           |
| 多项输出调试               | `Println`         |
| .cpp板子                   | `default`         |
| ios读入读出                | `ios`             |
| 常用const                  | `const`           |
| 常用typdef                 | `typedef`         |
| 泛型补全                   | `temp`            |
| 常用template               | `temp`            |
| 快读快写                   | `ll read`         |
| 常用头文件                 | `#incl`           |
| 常用main                   | `main`            |
| 偏移量判断出界             | `nx`              |
| memset初始化各种数组       | `memset`          |
| 快速幂                     | `ksm`             |
| 拓展欧几里得算法           | `exgcd`           |
| 欧拉筛质数                 | `ola`             |
| 字典树插入字符串求出现次数 | `insert`          |
| 并查集                     | `find`            |
| 匈牙利算法                 | `find`            |
| 加边函数不带权             | `add`             |
| 加边函数带权               | `add`             |
| 优先队列dijkstra           | `dijkstra`        |
| spfa判断是否有环           | `bool spfa`       |
| lowbit求最低位1            | `lowbit`          |
| lowbit树状数组             | `lowbit`          |
| 线段树                     | `build`           |
| AC自动机简单版             | `ac`              |
| AC自动机加强版             | `ac`              |
| manacher求最长回文串长度   | `manacher`        |
| manacher求最长回文子串     | `manacher`        |
| Lucas定理求组合数          | `lucas`           |
| min25筛                    | `min25`           |
| 杜教筛                     | `dujiao`          |
| 递归排序                   | `merge`           |
| topsort拓扑排序            | `topsort`         |
| 倍增lca求两点距离          | `lca`             |
| 倍增lca求最近公共祖先      | `lca`             |
| tarjan算法求割点           | `tarjan`          |
| tarjan算法求割边           | `tarjan`          |
| tarjan强连通分量           | `tarjan`          |
| 模拟退火                   | `simulate`        |
| add - 高精度加法           | `vector<int> add` |
| sub - 高精度减法           | `vector<int> sub` |
| mul - 高精度乘低精度       | `vector<int> mul` |
| div - 高精度除以低精度     | `vector<int> div` |
| 上左下右四方向偏移量       | `int dx`          |
| 八方向偏移量               | `int dx`          |
| 十二方向偏移量             | `int dx`          |
| 佛洛依德求最小环           | `floyd`           |
| kmp求最字符出现位置        | `kmp`             |
| inv线性求逆元              | `inv`             |
| splay树                    | `splay`           |
| 差分矩阵                   | `insert`          |
| 平板电视平衡树             | `pb_ds`           |
| 可持久化单点修改单点查询   | `build`           |
| 查询区间K小数(离线)        | `build`           |
| 线性基                     | `Linear_base`     |



```cpp
{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	// Ctrl + k + j一键折叠所有
	// Ctrl + k + 0一键展开所有
	//标准库万能头
	"标准库万能头": {
		"prefix": "#incl",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"$0"
		],
		"description": "Log output to console"
	},
	//多项输出调试
	"多项输出调试": {
		"prefix": "Println",
		"body": [
			"template<typename ...U>void Println(U... u) {",
			"\tint last_index = sizeof...(U) - 1, index = 0;",
			"\tauto printer = [last_index, &index]<typename Arg>(Arg arg){",
			"\t\tif (last_index == index++) cout << arg << endl;",
			"\t\telse cout << arg << \", \";};",
			"(printer(u), ...);}",
		],
		"description": "Log output to console"
	},
	// 模板
	"板子": {
		"prefix": "default",
		"body": [
			"#include <iostream>",
			"#include <cstring>",
			"#include <algorithm>",
			"#include <cmath>",
			"#include <numeric>",
			"#include <stack>",
			"#include <vector>",
			"#include <queue>",
			"#include <set>",
			"#include <map>",
			"#include <unordered_map>",
			"#include <unordered_set>",
			"#include <bitset>",
			"// #include <bits/stdc++.h>",
			"using namespace std;",
			"#define inf 0x3f3f3f3f",
			"#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)",
			"#define FREOPEN freopen(\"in.in\", \"r\", stdin);freopen(\"out.out\", \"w\", stdout)",
			"#define endl '\\n'",
			"namespace Template {",
			"\ttypedef long long ll;",
			"\ttypedef pair<int, int> PII;",
			"\ttypedef pair<int, PII> PIII;",
			"\ttypedef vector<int> VI;",
			"\ttypedef vector<ll> VL;",
			"\ttemplate<typename T> inline T Max(T &a, T b){if (a < b) a = b;return a;}",
			"\ttemplate<typename T> inline T Max(T &a, T b, T c){a = Max(a, b);a = Max(a, c);return a;}",
			"\ttemplate<typename T> inline T Min(T &a, T b){if (a > b) a = b;return a;}",
			"\ttemplate<typename T> inline T Min(T &a, T b, T c){a = Min(a, b);a = Min(a, c);return a;}",
			"\ttemplate<typename T> inline T Abs(T a){if (a < 0) a = -1 * a;return a;}",
			"\ttemplate<typename T>T Gcd(T a, T b){return b ? Gcd(b, a % b) : a;}",
			"\ttemplate<typename T> inline void Swap(T &a, T &b){T temp = a;a = b;b = temp;}",
			"\ttemplate<typename T> inline void read(T &x) {",
			"\t\tx = 0;short sgn = 1;char c = getchar();",
			"\t\twhile (c < 48 || 57 < c) {if (c == 45) sgn = -1;c = getchar();}",
			"\t\twhile (48 <= c && c <= 57) {x = (x << 3) + (x << 1) + c - 48;c = getchar();}",
			"\t\tx *= sgn;",
			"\t}",
			"\ttemplate<typename T, typename... Args> void read(T &first, Args& ... args) {",
			"\t\tread(first);read(args...);",
			"\t}",
			"\ttemplate<typename ...U>void Println(U... u) {",
			"\t\tint last_index = sizeof...(U) - 1, index = 0;",
			"\t\tauto printer = [last_index, &index]<typename Args>(Args args){",
			"\t\t\tif (last_index == index++) cout << args << endl;",
			"\t\t\telse cout << args << \", \";};",
			"\t\t(printer(u), ...);",
			"\t}",
			"}",
			"using namespace Template;",
			"",
			"const int N = 1e6 + 10, M = 2e6 + 10, mod = 1e9 + 7;",
			"",
			"",
			"",
			"void solve(int group_Id) {",
			"\t$0",
			"}",
			"",
			"signed main()",
			"{",
			"\t// IOS;",
			"#ifndef ONLINE_JUDGE",
			"\tFREOPEN;",
			"#endif",
			"\t// int T;read(T);",
			"\tint T = 1;",
			"\tfor (int i = 1;i <= T;i ++) solve(i);",
			"\treturn 0;",
			"}",
		],
		"description": "Log output to console"
	},
	"ios读入读出": {
		"prefix": "ios",
		"body": [
			"ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);",
			"$0",
		],
		"description": "Log output to console"
	},
	//常用const
	"const": {
		"prefix": "const",
		"body": [
			"const int N = 1e5 + 10, M = 2e5 + 10, mod = 1331;"
		],
		"description": "Log output to console"
	},
	//typedef
	"常用typedef": {
		"prefix": "typedef",
		"body": [
			"typedef long long ll;",
			"typedef pair<int, int> PII;",
			"typedef pair<int, PII> PIII;",
			"$0"
		],
		"description": "Log output to console"
	},
	//泛型补全
	"泛型补全": {
		"prefix": "temp",
		"body": [
			"template<typename T>",
		],
		"description": "Log output to console"
	},
	//常用template
	"常用template": {
		"prefix": "temp",
		"body": [
			"template<typename T>void Max(T &a, T b){if (a < b) a = b;}",
			"template<typename T>void Min(T &a, T b){if (a > b) a = b;}",
			"template<typename T>T Gcd(T a, T b){return b ? Gcd(b, a % b) : a;}",
			"template<typename T>void Swap(T &a, T &b){T temp = a;a = b;b = temp;}",
			"$0"
		],
		"description": "Log output to console"
	},
	//常用头文件
	"#include": {
		"prefix": "#incl",
		"body": [
			"#include <iostream>",
			"#include <cstring>",
			"#include <algorithm>",
			"using namespace std;",
			"#define inf 0x7f7f7f7f",
			"$0"
		],
		"description": "Log output to console"
	},
	//常用main
	"main主函数": {
		"prefix": "main",
		"body": [
			"signed main()",
			"{",
			"\tfreopen(\"in.in\", \"r\", stdin);freopen(\"out.out\", \"w\", stdout);",
			"\t$0",
			"\treturn 0;",
			"}"
		],
		"description": "Log output to console"
	},
	//偏移量判断出界
	"偏移量判断出界": {
		"prefix": "nx",
		"body": [
			"nx = x + dx[i], ny = y + dy[i];",
			"if (nx <= 0 || nx > n || ny <= 0 || ny > m) continue;",
			"$0"
		],
		"description": "Log output to console"
	},
	//快速幂
	"快速幂": {
		"prefix": "ksm",
		"body": [
			"ll ksm(ll a, ll b)",
			"{",
			"\tll res = 1ll;",
			"\twhile (b)",
			"\t{",
			"\t\tif (b & 1)",
			"\t\t\tres = (res * a) % mod;",
			"\t\ta = (a * a) % mod;",
			"\t\tb >>= 1;",
			"\t}",
			"\treturn res;",
			"}",
			"$0"
		],
		"description": "Log output to console"
	},
	//lowbit
	"最低位1": {
		"prefix": "lowbit",
		"body": [
			"int lowbit(int x) {",
			"\treturn x & -x;",
			"}",
			"$0"
		],
		"description": "Log output to console"
	},
	//lowbit树状数组
	"树状数组": {
		"prefix": "lowbit",
		"body": [
			"int lowbit(int x)",
			"{",
			"\treturn x & -x;",
			"}",
			"",
			"void update(int x, int c)  // 位置x加c",
			"{",
			"\tfor (int i = x;i <= n; i += lowbit(i)) tr[i] += c;",
			"}",
			"",
			"int getsum(int x)  // 返回前x个数的和",
			"{",
			"\tint res = 0;",
			"\tfor (int i = x;i > 0; i -= lowbit(i)) res += tr[i];",
			"\treturn res;",
			"}",
			"$0"
		],
		"description": "Log output to console"
	},
	//线段树
	"线段树": {
		"prefix": "build",
		"body": [
			"struct Node",
			"{",
			"\tint l, r;",
			"\t// TODO: 需要维护的信息和懒标记",
			"\t$0",
			"}tr[N * 4];",
			"",
			"void pushup(int u)",
			"{",
			"\t// TODO: 利用左右儿子信息维护当前节点的信息",
			"}",
			"",
			"void pushdown(int u)",
			"{",
			"\t// TODO: 将懒标记下传",
			"}",
			"",
			"void build(int u = 1, int l = 1, int r = n)",
			"{",
			"\ttr[u] = {l, r};",
			"\tif (l == r) {",
			"",
			"\t}",
			"\telse",
			"\t{",
			"\t\tint mid = l + r >> 1;",
			"\t\tbuild(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);",
			"\t\tpushup(u);",
			"\t}",
			"}",
			"",
			"void update(int l, int r, int d, int u = 1)",
			"{",
			"\tif (tr[u].l >= l && tr[u].r <= r)",
			"\t{",
			"\t\t// TODO: 修改区间",
			"\t}",
			"\telse",
			"\t{",
			"\t\tpushdown(u);",
			"\t\tint mid = tr[u].l + tr[u].r >> 1;",
			"\t\tif (l <= mid) update(l, r, d, u << 1);",
			"\t\tif (r > mid) update(l, r, d, u << 1 | 1);",
			"\t\tpushup(u);",
			"\t}",
			"}",
			"",
			"int query(int l, int r, int u = 1)",
			"{",
			"\tif (tr[u].l >= l && tr[u].r <= r)",
			"\t{",
			"\t\treturn ;  // TODO 需要补充返回值",
			"\t}",
			"\telse",
			"\t{",
			"\t\tpushdown(u);",
			"\t\tint mid = tr[u].l + tr[u].r >> 1;",
			"\t\tint res = 0;",
			"\t\tif (l <= mid ) res = query(l, r, u << 1);",
			"\t\tif (r > mid) res += query(l, r, u << 1 | 1);",
			"\t\treturn res;",
			"\t}",
			"}"
		],
		"description": "Log output to console"
	},
	//AC简单版
	"AC简单版": {
		"prefix": "ac",
		"body": [
			"namespace AC{",
			"\tint tr[N][26], fail[N], e[N], tot;",
			"",
			"\tvoid insert(char *s){// 字典树插入",
			"\t\tint u = 0;",
			"\t\tfor(int i = 1;s[i];i++){",
			"\t\t\tif(!tr[u][s[i] - 'a']) tr[u][s[i] - 'a'] = ++tot;",
			"\t\t\tu = tr[u][s[i] - 'a'];",
			"\t\t}",
			"\t\te[u]++;",
			"\t}",
			"",
			"\tqueue<int> q;",
			"\tvoid build(){// 计算fail指针",
			"\t\tfor(int i = 0;i < 26;i++){",
			"\t\t\tif(tr[0][i]) q.push(tr[0][i]);",
			"\t\t}",
			"\t\twhile(q.size()){",
			"\t\t\tint u = q.front();",
			"\t\t\tq.pop();",
			"\t\t\tfor(int i = 0;i < 26;i++){",
			"\t\t\t\tif(tr[u][i]){",
			"\t\t\t\t\tfail[tr[u][i]] = tr[fail[u]][i];",
			"\t\t\t\t\tq.push(tr[u][i]);",
			"\t\t\t\t}",
			"\t\t\t\telse tr[u][i] = tr[fail[u]][i];",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"\tint query(char *t){// 询问几个单词出现过、当且仅当编号不同",
			"\t\tint u = 0, res = 0;",
			"\t\tfor(int i = 1;t[i];i++){",
			"\t\t\tu = tr[u][t[i] - 'a'];",
			"\t\t\tfor(int j = u;j && ~e[j];j = fail[j]){",
			"\t\t\t\tres += e[j];",
			"\t\t\t\te[j] = -1;",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"}",
			"$0"
		],
		"description": "Log output to console"
	},
	//AC加强版
	"AC加强版": {
		"prefix": "ac",
		"body": [
			"namespace AC{",
			"\tint tr[M][26], fail[M], e[M], tot;//字典树 指针 标号",
			"\tint cnt[N], val[M];// cnt表示第i个字符串出现的次数",
			"\tvoid init(){// 初始化",
			"\t\tmemset(tr, 0, sizeof tr);",
			"\t\tmemset(fail, 0, sizeof fail);",
			"\t\tmemset(e, 0, sizeof e);",
			"\t\tmemset(cnt, 0, sizeof cnt);",
			"\t\tmemset(val, 0, sizeof val);",
			"\t\ttot = 0;",
			"\t}",
			"\tvoid insert(char *s, int id){// 字典树插入",
			"\t\tint u = 0;",
			"\t\tfor(int i = 1;s[i];i++){",
			"\t\t\tif(!tr[u][s[i] - 'a']) tr[u][s[i] - 'a'] = ++tot;",
			"\t\t\tu = tr[u][s[i] - 'a'];",
			"\t\t}",
			"\t\te[u] = id;",
			"\t}",
			"\tqueue<int> q;",
			"\tvoid build(){// 计算fail指针",
			"\t\tfor(int i = 0;i < 26;i++)",
			"\t\t\tif(tr[0][i]) q.push(tr[0][i]);",
			"\t\twhile(q.size()){",
			"\t\t\tint u = q.front();",
			"\t\t\tq.pop();",
			"\t\t\tfor(int i = 0; i < 26;i++){",
			"\t\t\t\tif(tr[u][i]){",
			"\t\t\t\t\tfail[tr[u][i]] = tr[fail[u]][i];",
			"\t\t\t\t\tq.push(tr[u][i]);",
			"\t\t\t\t}else tr[u][i] = tr[fail[u]][i];",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"\tint query(char *t){// 询问每个单词出现次数、返回最大次数",
			"\t\tint u = 0, res = 0;",
			"\t\tfor(int i = 1;t[i];i++){",
			"\t\t\tu = tr[u][t[i] - 'a'];",
			"\t\t\tfor(int j = u;j;j = fail[j]) val[j]++;",
			"\t\t}",
			"\t\tfor(int i = 1;i <= tot;i++){",
			"\t\t\tif(e[i]){",
			"\t\t\t\tres = max(res, val[i]);",
			"\t\t\t\tcnt[e[i]] = val[i];// 通过标号得到次数",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"}"
		],
		"description": "Log output to console"
	},
	//字符串马拉车
	"manacher求最长回文串长度": {
		"prefix": "manacher",
		"body": [
			"string str, nstr;",
			"int lens[2 * N];",
			"",
			"void init()//返回字符串长度、str为字符串、nstr为新字符串",
			"{",
			"\tint j = 2;",
			"\tnstr += '@', nstr += '#';",
			"\tfor (int i = 0; i < str.length(); i++)",
			"\t{",
			"\t\tnstr += str[i];",
			"\t\tnstr += '#';",
			"\t}",
			"\tnstr += '*';",
			"}",
			"",
			"int man()//返回最长字符串、len为字符串长度",
			"{",
			"\tint mx = 0, id = 1, max_len = 0;",
			"\tfor (int i = 1; i < nstr.length(); i++)",
			"\t{",
			"\t\tlens[i] = i < mx ? min(mx - i, lens[2 * id - i]) : 1;",
			"\t\twhile (nstr[i + lens[i]] == nstr[i - lens[i]]) lens[i]++;",
			"\t\tif (lens[i] + i > mx)",
			"\t\t{",
			"\t\t\tmx = lens[i] + i;",
			"\t\t\tid = i;",
			"\t\t}",
			"\t\tmax_len = max(max_len, lens[i]);",
			"\t}",
			"\treturn max_len - 1;",
			"}",
			"$0"
		],
		"description": "Log output to console"
	},
	"manacher求最长回文子串": {
		"prefix": "manacher",
		"body": [
			"string str, nstr;",
			"int lens[2 * N];",
			"",
			"void init()//str为字符串、nstr为新字符串",
			"{",
			"\tint j = 2;",
			"\tnstr += '@', nstr += '#';",
			"\tfor (int i = 0; i < str.length(); i++)",
			"\t{",
			"\t\tnstr += str[i];",
			"\t\tnstr += '#';",
			"\t}",
			"\tnstr += '*';",
			"}",
			"",
			"string man() {//返回最长字符子串、len为字符串长度",
			"\tint mx = 0, id = 1, max_len = 0, startx = 2, lenx = 1;",
			"\tfor (int i = 1; i < nstr.length(); i++)",
			"\t{",
			"\t\tlens[i] = i < mx ? min(mx - i, lens[2 * id - i]) : 1;",
			"\t\twhile (nstr[i + lens[i]] == nstr[i - lens[i]]) lens[i]++;",
			"\t\tif(lens[i] > max_len){",
			"\t\t\t\tstartx = i;",
			"\t\t\t\tlenx = lens[i];",
			"\t\t\t}",
			"\t\tif (lens[i] + i > mx)",
			"\t\t{",
			"\t\t\tmx = lens[i] + i;",
			"\t\t\tid = i;",
			"\t\t}",
			"\t\tmax_len = max(max_len, lens[i]);",
			"\t}",
			"\tnstr = nstr.substr(startx, lenx);",
			"\tif((max_len - 1) & 1){",
			"\t\tstring str = nstr.substr(1);",
			"\t\treverse(str.begin(), str.end());",
			"\t\tnstr = str + nstr;",
			"\t}else{",
			"\t\treverse(nstr.begin(), nstr.end());",
			"\t\tstring str = nstr;",
			"\t\treverse(nstr.begin(), nstr.end());",
			"\t\tnstr = str + nstr;",
			"\t}",
			"\tstring cc = \"\";",
			"\tfor(int i = 0;i < nstr.length();i++){",
			"\t\tif(nstr[i] != '#') cc += nstr[i];",
			"\t}",
			"\treturn cc;",
			"}",
			"$0"
		],
		"description": "Log output to console"
	},
	//Lucas定理
	"Lucas定理": {
		"prefix": "lucas",
		"body": [
			"ll quick_pow(ll a, ll n, ll q)",
			"{",
			"\tll ret = 1;",
			"\ta %= q;",
			"\twhile (n)",
			"\t{",
			"\t\tif (n & 1)",
			"\t\t\tret = ret * a % q;",
			"\t\ta = a * a % q;",
			"\t\tn >>= 1;",
			"\t}",
			"\treturn ret;",
			"}",
			"ll getc(ll n, ll m, ll q)",
			"{",
			"\tif (n < m)",
			"\t\treturn 0;",
			"\tif (m > n - m)",
			"\t\tm = n - m;",
			"\tll s1 = 1, s2 = 1;",
			"\tfor (int i = 0; i < m; ++i)",
			"\t{",
			"\t\ts1 = s1 * (n - i) % q;",
			"\t\ts2 = s2 * (i + 1) % q;",
			"\t}",
			"\treturn s1 * quick_pow(s2, q - 2, q) % q;",
			"}",
			"ll lucas(ll n, ll m, ll q)",
			"{",
			"\tif (!m)",
			"\t\treturn 1;",
			"\treturn getc(n % q, m % q, q) * lucas(n / q, m / q, q) % q;",
			"}",
			"$0",
		],
		"description": "Log output to console"
	},
	//min25筛
	"min25筛": {
		"prefix": "min25",
		"body": [
			"inline ll FUN(ll v, ll N, ll nd, ll nv) { return v >= nd ? (N / v - 1) : (nv - v); }",
			"ll PrimeSum(ll N)",
			"{",
			"\tll *S, *V, r = (ll)sqrt(N);",
			"\tll nd = N / r;",
			"\tll nv = r + nd - 1;",
			"\tV = new ll[nv], S = new ll[nv];",
			"\tfor (ll i = 0; i < r; i++)",
			"\t\tV[i] = N / (i + 1);",
			"\tfor (ll i = r; i < nv; i++)",
			"\t\tV[i] = V[i - 1] - 1;",
			"\tfor (ll i = 0; i < nv; i++)",
			"\t\tS[i] = V[i] * (V[i] + 1) / 2 - 1;",
			"\tfor (ll p = 2; p <= r; p++)",
			"\t{",
			"\t\tif (S[nv - p] > S[nv - p + 1])",
			"\t\t{",
			"\t\t\tll sp = S[nv - p + 1];",
			"\t\t\tll p2 = p * p;",
			"\t\t\tfor (ll i = 0; i < nv; i++)",
			"\t\t\t{",
			"\t\t\t\tif (V[i] >= p2)",
			"\t\t\t\t\tS[i] -= p * (S[FUN(V[i] / p, N, nd, nv)] - sp);",
			"\t\t\t\telse",
			"\t\t\t\t\tbreak;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\treturn S[0];",
			"}",
			"$0"
		],
		"description": "Log output to console"
	},
	//杜教筛 dujiao
	"杜教筛": {
		"prefix": "dujiao",
		"body": [
			"typedef long long ll;",
			"const int mod = 1000000007;",
			"const int maxn = 5000000;",
			"ll pai[maxn + 5];",
			"int prim[maxn + 5], cnt, mu[maxn + 5];",
			"bool vis[maxn + 5];",
			"unordered_map<int, int> ans_mu;",
			"unordered_map<int, ll> ans_pai;",
			"void init()",
			"{",
			"\tmu[1] = pai[1] = 1;",
			"\tfor (int i = 2; i <= maxn; ++i)",
			"\t{",
			"\t\tif (!vis[i])",
			"\t\t\tprim[++cnt] = i, mu[i] = -1, pai[i] = i - 1;",
			"\t\tfor (int j = 1; j <= cnt && prim[j] * i <= maxn; ++j)",
			"\t\t{",
			"\t\t\tvis[prim[j] * i] = 1;",
			"\t\t\tif (i % prim[j] == 0)",
			"\t\t\t{",
			"\t\t\t\tpai[i * prim[j]] = pai[i] * prim[j];",
			"\t\t\t\tbreak;",
			"\t\t\t}",
			"\t\t\tpai[i * prim[j]] = pai[prim[j]] * pai[i];",
			"\t\t\tmu[i * prim[j]] = -mu[i];",
			"\t\t}",
			"\t}",
			"\tfor (int i = 1; i <= maxn; ++i)",
			"\t\tmu[i] += mu[i - 1], pai[i] += pai[i - 1];",
			"}",
			"//φ前缀和",
			"ll get_pai(ll x)",
			"{",
			"\tif (x <= maxn)",
			"\t\treturn pai[x];",
			"\tif (ans_pai[x])",
			"\t\treturn ans_pai[x];",
			"\tll ans = ((1ll + x) * x) / 2ll;",
			"\tfor (int l = 2, r; l <= x; l = r + 1)",
			"\t{",
			"\t\tr = x / (x / l);",
			"\t\tans -= 1ll * (r - l + 1) * get_pai(x / l);",
			"\t}",
			"\treturn ans_pai[x] = ans;",
			"}",
			"//i * φ前缀和",
			"ll get_piai(ll x)",
			"{",
			"\tif (x <= maxn)",
			"\t\treturn pai[x];",
			"\tif (ans_pai[x])",
			"\t\treturn ans_pai[x];",
			"\tll ans = x * (x + 1ll) * (2ll * x + 1ll) / (ll)6;",
			"\tfor (int l = 2, r; l <= x; l = r + 1)",
			"\t{",
			"\t\tr = x / (x / l);",
			"\t\tans -= 1ll * (r - l + 1) * get_piai(x / l);",
			"\t}",
			"\treturn ans_pai[x] = ans;",
			"}",
			"//μ前缀和",
			"int get_mu(int x)",
			"{",
			"\tif (x <= maxn)",
			"\t\treturn mu[x];",
			"\tif (ans_mu[x])",
			"\t\treturn ans_mu[x];",
			"\tint ans = 1;",
			"\tfor (int l = 2, r; l <= x; l = r + 1)",
			"\t{",
			"\t\tr = x / (x / l);",
			"\t\tans -= (r - l + 1) * get_mu(x / l);",
			"\t}",
			"\treturn ans_mu[x] = ans;",
			"}",
			"//i * μ前缀和",
			"int get_miu(int x)",
			"{",
			"\tif (x <= maxn)",
			"\t\treturn mu[x];",
			"\tif (ans_mu[x])",
			"\t\treturn ans_mu[x];",
			"\tint ans = 1;",
			"\tfor (int l = 2, r; l <= x; l = r + 1)",
			"\t{",
			"\t\tr = x / (x / l);",
			"\t\tans -= (r - l + 1) * l * get_miu(x / l);",
			"\t}",
			"\treturn ans_mu[x] = ans;",
			"}",
			"void doit()",
			"{",
			"\tint T = read();",
			"\twhile (T--)",
			"\t{",
			"\t\tint x = read();",
			"\t\t//TODO:选择要输出的",
			"\t}",
			"}",
			"$0"
		],
		"description": "Log output to console"
	},
	//递归排序
	"递归排序": {
		"prefix": "merge",
		"body": [
			"void merge_sort(int q[], int l, int r)  // 归并排序",
			"{",
			"\tif (l >= r) return;",
			"",
			"\tint mid = l + r >> 1;",
			"\tmerge_sort(q, l, mid);",
			"\tmerge_sort(q, mid + 1, r);",
			"",
			"\tint k = 0, i = l, j = mid + 1;",
			"\twhile (i <= mid && j <= r)",
			"\t\tif (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];",
			"\t\telse tmp[k ++ ] = q[j ++ ];",
			"",
			"\twhile (i <= mid) tmp[k ++ ] = q[i ++ ];",
			"\twhile (j <= r) tmp[k ++ ] = q[j ++ ];",
			"",
			"\tfor (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];",
			"}",
			"$0"
		],
		"description": "Log output to console"
	},
	//topsort拓扑排序
	"拓扑排序": {
		"prefix": "topsort",
		"body": [
			"bool topsort()",
			"{",
			"\tint hh = 0, tt = -1;",
			"",
			"\t// d[i] 存储点i的入度",
			"\tfor (int i = 1; i <= n; i ++ )",
			"\t\tif (!d[i])",
			"\t\t\tq[ ++ tt] = i;",
			"",
			"\twhile (hh <= tt)",
			"\t{",
			"\t\tint t = q[hh ++ ];",
			"",
			"\t\tfor (int i = h[t]; i != -1; i = ne[i])",
			"\t\t{",
			"\t\t\tint j = e[i];",
			"\t\t\tif (-- d[j] == 0)",
			"\t\t\t\tq[ ++ tt] = j;",
			"\t\t}",
			"\t}",
			"",
			"\t// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。",
			"\treturn tt == n - 1;",
			"}",
			"$0"
		],
		"description": "Log output to console"
	},
	//最近公共祖先
	"倍增lca求两点距离": {
		"prefix": "lca",
		"body": [
			"//存图",
			"int h[N], e[M], ne[M], w[M], idx;",
			"//fa[u][i]表示u的第2^i个祖先,dist[u][i]表示u到第2^i个祖先的距离,dep[u]表示u的深度",
			"int fa[N][31], dist[N][31], dep[N];",
			"",
			"inline void add (int a, int b, int c) {",
			"\te[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;",
			"}",
			"",
			"void dfs (int u, int father) {",
			"\tfa[u][0] = father;//当前点的第2^0个祖先就是我的父亲",
			"\tdep[u] = dep[fa[u][0]] + 1;//当前点的深度就是父亲的深度 + 1",
			"",
			"\tfor (int i = 1;i < 31;i ++) {",
			"\t\t//u的第2^i个祖先,就是第2^(i - 1)个祖先的第2^(i - 1)个祖先",
			"\t\tfa[u][i] = fa[fa[u][i - 1]][i - 1];",
			"\t\t//u到第2^i个祖先的距离就是u到第2^(i - 1)个祖先的距离加上第2^(i - 1)个祖先到他的2^(i - 1)个祖先的距离",
			"\t\tdist[u][i] = dist[u][i - 1] + dist[fa[u][i - 1]][i - 1];",
			"\t}",
			"",
			"\tfor (int i = h[u];~i;i = ne[i]) {//遍历子节点",
			"\t\tint j = e[i];",
			"\t\tif (j == father) continue;",
			"\t\tdist[j][0] = w[i];",
			"\t\tdfs(j, u);",
			"\t}",
			"}",
			"",
			"int lca (int x, int y) {",
			"\tint res = 0;",
			"",
			"\tif(dep[x] > dep[y]) swap(x, y);//令y为深度大的点",
			"",
			"\tint tmp = dep[y] - dep[x];//得到深度差",
			"\tfor (int j = 0;tmp;j ++, tmp >>= 1) {//二进制递减深度",
			"\t\tif(tmp & 1) res += dist[y][j], y = fa[y][j];",
			"\t}",
			"",
			"\tif (x == y) return res;//如果x == y,证明x和y在同一个小子树上，直接返回结果",
			"",
			"\t//如果不在一个小子树上,继续往上找",
			"\tfor (int i = 30;i >= 0;i --) {//这里从上往下，使得x和y到距离最近公共祖先最近的点",
			"\t\tif (fa[x][i] != fa[y][i]) {",
			"\t\t\tres += dist[x][i] + dist[y][i];",
			"\t\t\tx = fa[x][i];",
			"\t\t\ty = fa[y][i];",
			"\t\t}",
			"\t}",
			"",
			"\tres += dist[x][0] + dist[y][0];//最后把从x和y到最近公共祖先的距离也加上",
			"",
			"\treturn res;",
			"}",
			"$0"
		],
		"description": "Log output to console"
	},
	//最近公共祖先
	"倍增lca求最近公共祖先": {
		"prefix": "lca",
		"body": [
			"//存图",
			"int h[N], e[M], ne[M], idx;",
			"//fa[u][i]表示u的第2^i个祖先,dist[u][i]表示u到第2^i个祖先的距离,dep[u]表示u的深度",
			"int fa[N][31], dist[N][31], dep[N];",
			"",
			"inline void add (int a, int b) {",
			"\te[idx] = b, ne[idx] = h[a], h[a] = idx++;",
			"}",
			"",
			"void dfs (int u, int father) {",
			"\tfa[u][0] = father;//当前点的第2^0个祖先就是我的父亲",
			"\tdep[u] = dep[fa[u][0]] + 1;//当前点的深度就是父亲的深度 + 1",
			"",
			"\tfor (int i = 1;i < 31;i ++) {",
			"\t\tfa[u][i] = fa[fa[u][i - 1]][i - 1];//u的第2^i个祖先,就是第2^(i - 1)个祖先的第2^(i - 1)个祖先",
			"\t}",
			"",
			"\tfor (int i = h[u];~i;i = ne[i]) {//遍历子节点",
			"\t\tint j = e[i];",
			"\t\tif (j == father) continue;",
			"\t\tdfs(j, u);",
			"\t}",
			"}",
			"",
			"int lca (int x, int y) {",
			"",
			"\tif(dep[x] > dep[y]) swap(x, y);//令y为深度大的点",
			"",
			"\tint tmp = dep[y] - dep[x];//得到深度差",
			"\tfor (int j = 0;tmp;j ++, tmp >>= 1) {//二进制递减深度",
			"\t\tif(tmp & 1) y = fa[y][j];",
			"\t}",
			"",
			"\tif (x == y) return x;",
			"",
			"\t//如果不在一个小子树上,继续往上找",
			"\tfor (int i = 30;i >= 0;i --) {//这里从上往下，使得x和y到距离最近公共祖先最近的点",
			"\t\tif (fa[x][i] != fa[y][i]) {",
			"\t\t\tx = fa[x][i];",
			"\t\t\ty = fa[y][i];",
			"\t\t}",
			"\t}",
			"",
			"\treturn fa[x][0];",
			"}",
			"$0"
		],
		"description": "Log output to console"
	},
	//自带数组
	"加边函数不带权": {
		"prefix": "add",
		"body": [
			"int h[N], e[M], ne[M], idx;",
			"void add(int a, int b)  // 添加一条边a->b",
			"{",
			"\te[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;",
			"}",
			"$0"
		],
		"description": "Log output to console"
	},
	//自带数组
	"加边函数带权": {
		"prefix": "add",
		"body": [
			"int h[N], e[M], ne[M], w[M], idx;",
			"void add(int a, int b, int c)  // 添加一条边a->b，边权为c",
			"{",
			"\te[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;",
			"}",
			"$0"
		],
		"description": "Log output to console"
	},
	//memset初始化h数组
	"初始化h数组": {
		"prefix": "memset",
		"body": [
			"memset(h, -1, sizeof h);",
			"$0"
		],
		"description": "Log output to console"
	},
	// memset初始化st数组
	"初始化st数组": {
		"prefix": "memset",
		"body": [
			"memset(st, 0, sizeof st);",
			"$0"
		],
		"description": "Log output to console"
	},
	// memset初始化dis数组
	"初始化dis数组": {
		"prefix": "memset",
		"body": [
			"memset(dis, 127, sizeof dis);",
			"$0"
		],
		"description": "Log output to console"
	},
	//拓展欧几里得算法
	"拓展欧几里得算法": {
		"prefix": "exgcd",
		"body": [
			"int exgcd(int a, int b, int &x, int &y)  // 扩展欧几里得算法, 求x, y，使得ax + by = gcd(a, b)",
			"{",
			"\tif (!b)",
			"\t{",
			"\t\tx = 1; y = 0;",
			"\t\treturn a;",
			"\t}",
			"\tint d = exgcd(b, a % b, y, x);",
			"\ty -= (a / b) * x;",
			"\treturn d;",
			"}",
			"$0"
		],
		"description": "Log output to console"
	},
	//优化并查集
	"并查集": {
		"prefix": "find",
		"body": [
			"int find(int x)  // 并查集",
			"{",
			"\tif (fa[x] != x) fa[x] = find(fa[x]);",
			"\treturn fa[x];",
			"}",
			"$0"
		],
		"description": "Log output to console"
	},
	//匈牙利算法
	"匈牙利算法": {
		"prefix": "find",
		"body": [
			"bool find(int x)",
			"{",
			"\tfor (int i = h[x]; i != -1; i = ne[i])",
			"\t{",
			"\t\tint j = e[i];",
			"\t\tif (!st[j])",
			"\t\t{",
			"\t\t\tst[j] = true;",
			"\t\t\tif (match[j] == 0 || find(match[j]))// 如果j还没有配对，或者j可以跟其他点配对",
			"\t\t\t{",
			"\t\t\t\tmatch[j] = x;// 那么j就跟我配对",
			"\t\t\t\treturn true;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\treturn false;",
			"}",
			"$0"
		],
		"description": "Log output to console"
	},
	//字典树插入字符串
	"字典树插入字符串求出现次数": {
		"prefix": "insert",
		"body": [
			"int son[N][26], cnt[N], idx;",
			"",
			"void insert(char *str)  // 插入字符串",
			"{",
			"\tint p = 0;",
			"\tfor (int i = 0; str[i]; i ++ )",
			"\t{",
			"\t\tint u = str[i] - 'a';",
			"\t\tif (!son[p][u]) son[p][u] = ++ idx;",
			"\t\tp = son[p][u];",
			"\t}",
			"\tcnt[p] ++ ;",
			"}",
			"",
			"int query(char *str)  // 查询字符串出现次数",
			"{",
			"\tint p = 0;",
			"\tfor (int i = 0; str[i]; i ++ )",
			"\t{",
			"\t\tint u = str[i] - 'a';",
			"\t\tif (!son[p][u]) return 0;",
			"\t\tp = son[p][u];",
			"\t}",
			"\treturn cnt[p];",
			"}",
			"$0"
		],
		"description": "Log output to console"
	},
	//优先队列dijkstra
	"优先队列1-n最短路": {
		"prefix": "dijkstra",
		"body": [
			"void dijkstra()  // 求1号点到n号点的最短路距离",
			"{",
			"\tmemset(dist, 0x3f, sizeof dist);",
			"\tdist[1] = 0;",
			"\tpriority_queue<PII, vector<PII>, greater<PII>> heap;",
			"\theap.push({0, 1});",
			"",
			"\twhile (heap.size())",
			"\t{",
			"\t\tauto t = heap.top();",
			"\t\theap.pop();",
			"",
			"\t\tint ver = t.second, distance = t.first;",
			"",
			"\t\tif (st[ver]) continue;",
			"\t\tst[ver] = true;",
			"",
			"\t\tfor (int i = h[ver]; i != -1; i = ne[i])",
			"\t\t{",
			"\t\t\tint j = e[i];",
			"\t\t\tif (dist[j] > dist[ver] + w[i])",
			"\t\t\t{",
			"\t\t\t\tdist[j] = dist[ver] + w[i];",
			"\t\t\t\theap.push({dist[j], j});",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"}",
			"$0"
		],
		"description": "Log output to console"
	},
	//add - 高精度加法
	"add - 高精度加法": {
		"prefix": "vector<int> add",
		"body": [
			"vector<int> add(vector<int> &A, vector<int> &B)  // C = A + B, A >= 0, B >= 0",
			"{",
			"\tif (A.size() < B.size()) return add(B, A);",
			"",
			"\tvector<int> C;",
			"\tint t = 0;",
			"\tfor (int i = 0; i < A.size(); i ++ )",
			"\t{",
			"\t\tt += A[i];",
			"\t\tif (i < B.size()) t += B[i];",
			"\t\tC.push_back(t % 10);",
			"\t\tt /= 10;",
			"\t}",
			"",
			"\tif (t) C.push_back(t);",
			"\treturn C;",
			"}",
			"$0"
		],
		"description": "Log output to console"
	},
	//sub - 高精度减法
	"sub - 高精度减法": {
		"prefix": "vector<int> sub",
		"body": [
			"vector<int> sub(vector<int> &A, vector<int> &B)  // C = A - B, 满足A >= B, A >= 0, B >= 0",
			"{",
			"\tvector<int> C;",
			"\tfor (int i = 0, t = 0; i < A.size(); i ++ )",
			"\t{",
			"\t\tt = A[i] - t;",
			"\t\tif (i < B.size()) t -= B[i];",
			"\t\tC.push_back((t + 10) % 10);",
			"\t\tif (t < 0) t = 1;",
			"\t\telse t = 0;",
			"\t}",
			"",
			"\twhile (C.size() > 1 && C.back() == 0) C.pop_back();",
			"\treturn C;",
			"}",
			"$0"
		],
		"description": "Log output to console"
	},
	//mul - 高精度乘低精度
	"mul - 高精度乘低精度": {
		"prefix": "vector<int> mul",
		"body": [
			"vector<int> mul(vector<int> &A, int b)  // C = A * b, A >= 0, b >= 0",
			"{",
			"\tvector<int> C;",
			"",
			"\tint t = 0;",
			"\tfor (int i = 0; i < A.size() || t; i ++ )",
			"\t{",
			"\t\tif (i < A.size()) t += A[i] * b;",
			"\t\tC.push_back(t % 10);",
			"\t\tt /= 10;",
			"\t}",
			"",
			"\twhile (C.size() > 1 && C.back() == 0) C.pop_back();",
			"",
			"\treturn C;",
			"}",
			"$0"
		],
		"description": "Log output to console"
	},
	//div - 高精度除以低精度
	"div - 高精度除以低精度": {
		"prefix": "vector<int> div",
		"body": [
			"vector<int> div(vector<int> &A, int b, int &r)  // A / b = C ... r, A >= 0, b > 0",
			"{",
			"\tvector<int> C;",
			"\tr = 0;",
			"\tfor (int i = A.size() - 1; i >= 0; i -- )",
			"\t{",
			"\t\tr = r * 10 + A[i];",
			"\t\tC.push_back(r / b);",
			"\t\tr %= b;",
			"\t}",
			"\treverse(C.begin(), C.end());",
			"\twhile (C.size() > 1 && C.back() == 0) C.pop_back();",
			"\treturn C;",
			"}",
			"$0"
		],
		"description": "Log output to console"
	},
	//欧拉筛质数
	"欧拉筛质数": {
		"prefix": "ola",
		"body": [
			"int st[N], primes[N], cnt;",
			"void ola(int n)",
			"{",
			"\tfor (int i = 2; i <= n; i++)",
			"\t{",
			"\t\tif (st[i] == 0)",
			"\t\t\tprimes[cnt++] = i;                   //将质数存到primes中",
			"\t\tfor (int j = 0; primes[j] * i <= n; j++) //要确保质数的第i倍是小于等于n的。",
			"\t\t{",
			"\t\t\tst[primes[j] * i] = 1;",
			"\t\t\tif (i % primes[j] == 0)",
			"\t\t\t\tbreak;",
			"\t\t}",
			"\t}",
			"}",
			"$0"
		],
		"description": "Log output to console"
	},
	//spfa判断是否有环
	"判断是否有环": {
		"prefix": "bool spfa",
		"body": [
			"bool spfa() {",
			"// 如果存在负环，则返回true，否则返回false。",
			"// 不需要初始化dist数组",
			"// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，",
			"// 由抽屉原理一定有两个点相同，所以存在环。",
			"\tint hh = 0, tt = 0;",
			"",
			"\tfor (int i = 1; i <= n; i ++ ) q[tt ++ ] = i, st[i] = true, dist[i] = cnt[i] = 0;",
			"",
			"\twhile (hh != tt)",
			"\t{",
			"\t\tint t = q[hh ++ ];",
			"\t\tif (hh == N) hh = 0;",
			"\t\tst[t] = false;",
			"",
			"\t\tfor (int i =  h[t]; ~i; i = ne[i])",
			"\t\t{",
			"\t\t\tint j = e[i];",
			"\t\t\tif (dist[j] > dist[t] + w[i])",
			"\t\t\t{",
			"\t\t\t\tdist[j] = dist[t]  + w[i];",
			"\t\t\t\tcnt[j] = cnt[t] + 1;",
			"\t\t\t\tif (cnt[j] >= n) return true;",
			"\t\t\t\tif (!st[j])",
			"\t\t\t\t{",
			"\t\t\t\t\tst[j] = true;",
			"\t\t\t\t\tq[tt ++ ] = j;",
			"\t\t\t\t\tif (tt == N) tt = 0;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"\treturn false;",
			"}",
			"$0"
		],
		"description": "Log output to console"
	},
	//tarjan算法求割点
	"tarjan割点": {
		"prefix": "tarjan",
		"body": [
			"//dfn(u)为节点u搜索的次序编号(时间戳),low(u)为u或u的子树能够追溯到的最早的栈中节点的次序号",
			"int dfn[N], low[N];",
			"int dindex;//dindex为时间戳",
			"int h[N], e[N * 2], ne[N * 2], idx;//邻接表存图",
			"int cut[N];",
			"int n, m, stop, bcnt;",
			"",
			"inline void add(int a, int b) {",
			"\te[idx] = b, ne[idx] = h[a], h[a] = idx++;",
			"}",
			"",
			"void tarjan(int u, int fa) {",
			"\tdfn[u] = low[u] = ++dindex;//初始都为时间戳",
			"\tint child=0;",
			"",
			"\tfor (int i = h[u];~i;i = ne[i]) {",
			"\t\tint j = e[i];",
			"\t\tif (!dfn[j]){",
			"\t\t\ttarjan(j, fa);",
			"\t\t\tlow[u] = min(low[u], low[j]);",
			"\t\t\tif (low[j] >= dfn[u] && u != fa)",
			"\t\t\t\tcut[u] = 1;",
			"\t\t\tif(u == fa)",
			"\t\t\t\tchild++;",
			"",
			"\t\t}",
			"\t\tlow[u] = min (low[u], dfn[j]);",
			"\t}",
			"\tif (child >= 2 && u == fa)",
			"\t\tcut[u] = 1;",
			"}",
			"",
			"void solve() {",
			"\tmemset (h, -1, sizeof h);",
			"\tmemset (dfn, 0, sizeof dfn);",
			"\tstop = bcnt = dindex = 0;",
			"",
			"\tcin >> n >> m;",
			"\tfor (int i = 1;i <= m;i ++) {",
			"\t\tint a, b;",
			"\t\tcin >> a >> b;",
			"\t\tadd(a, b);",
			"\t\tadd(b, a);",
			"\t}",
			"",
			"\tfor (int i = 1;i <= n;i ++) {",
			"\t\tif(!dfn[i]) tarjan(i, i);",
			"\t}",
			"}",
			"$0"
		],
		"description": "Log output to console"
	},
	//tarjan算法求割边
	"tarjan算法求割边": {
		"prefix": "tarjan",
		"body": [
			"int low[N], dfn[N], father[N];//dfn(u)为节点u搜索的次序编号(时间戳),low(u)为u或u的子树能够追溯到的最早的栈中节点的次序号",
			"int dfs_clock, cnt_bridge;//dfs_clock时间戳、cnt_bridge割边数量",
			"bool isbridge[N];//是否是割边",
			"int h[N], e[N * 2], ne[N * 2], idx;//邻接表存图",
			"vector<PII> res;// 割边集合",
			"int n, m;",
			"",
			"inline void add(int a, int b) {",
			"\te[idx] = b, ne[idx] = h[a], h[a] = idx++;",
			"}",
			"",
			"void tarjan(int u, int fa) {",
			"\tfather[u] = fa;//父亲节点",
			"\tlow[u] = dfn[u] = ++dfs_clock;",
			"\tfor (int i = h[u];~i;i = ne[i]) {",
			"\t\tint v = e[i];",
			"\t\tif (!dfn[v]) {",
			"\t\ttarjan(v, u);",
			"\t\tlow[u] = min(low[u], low[v]);",
			"\t\tif (low[v] > dfn[u]) {",
			"\t\t\tisbridge[v] = true;// 如果isbridge为真表示father[v] -> v为一条割边",
			"\t\t\tres.push_back({father[v], v});",
			"\t\t\t++cnt_bridge;",
			"\t\t}",
			"\t\t} else if (dfn[v] < dfn[u] && v != fa) {",
			"\t\tlow[u] = min(low[u], dfn[v]);",
			"\t\t}",
			"\t}",
			"}",
			"",
			"void solve() {",
			"\tmemset(h, -1, sizeof h);",
			"\tcin >> n >> m;",
			"\tfor (int i = 1;i <= m;i ++) {",
			"\t\tint a, b;",
			"\t\tcin >> a >> b;",
			"\t\tadd(a, b);",
			"\t}",
			"\tfor (int i = 1;i <= n;i ++) {",
			"\t\tif (!dfn[i]) tarjan(i, i);",
			"\t}",
			"",
			"\tfor (PII i : res) {// 输出割边",
			"\t\tcout << i.first << \" \" << i.second << endl;",
			"\t}",
			"}",
			"$0"
		],
		"description": "Log output to console"
	},
	//tarjan强连通分量
	"tarjan强连通分量": {
		"prefix": "tarjan",
		"body": [
			"int dfn[N], low[N], sta[N], gro[N], tot[N];",
			"bool instack[N];//是否在栈内",
			"int stop, bcnt, dindex;//stop栈内元素个数,bcnt为分组的组号,dindex为时间戳",
			"int h[N], e[N], ne[N], idx;//邻接表存图",
			"int n, m;",
			"",
			"inline void add(int a, int b) {",
			"\te[idx] = b, ne[idx] = h[a], h[a] = idx++;",
			"}",
			"",
			"void tarjan(int u) {",
			"\tdfn[u] = low[u] = ++dindex;//初始都为时间戳",
			"\tinstack[u] = true;//加入栈内",
			"\tsta[++stop] = u;",
			"\tfor (int i = h[u];~i;i = ne[i]) {",
			"\t\tint j = e[i];",
			"\t\tif (!dfn[j]){",
			"\t\t\ttarjan(j);",
			"\t\t\tif (low[j] < low[u]) low[u] = low[j];",
			"\t\t}else if (instack[j] && dfn[j] < low[u]) low[u] = dfn[j];",
			"\t}",
			"\tif (dfn[u] == low[u]) {",
			"\t\tbcnt++;",
			"\t\tint j;",
			"\t\tdo {",
			"\t\t\tj = sta[stop--];",
			"\t\t\tinstack[j] = false;",
			"\t\t\tgro[j] = bcnt;",
			"\t\t\ttot[bcnt]++;",
			"\t\t}while (j != u);",
			"\t}",
			"}",
			"",
			"void solve() {",
			"\tmemset (h, -1, sizeof h);",
			"\tmemset (dfn, 0, sizeof dfn);",
			"\tstop = bcnt = dindex = 0;",
			"",
			"\tcin >> n >> m;",
			"\tfor (int i = 1;i <= m;i ++) {",
			"\t\tint a, b;",
			"\t\tcin >> a >> b;",
			"\t\tadd(a, b);",
			"\t}",
			"",
			"\tfor (int i = 1;i <= n;i ++) {",
			"\t\tif(!dfn[i]) tarjan(i);",
			"\t}",
			"}",
			"$0"
		],
		"description": "Log output to console"
	},
	//快读快写
	"快读快写": {
		"prefix": "read",
		"body": [
			"inline int read(void) {",
			"\tint x = 0;",
			"\tshort sgn = 1;",
			"\tchar c = getchar();",
			"\twhile (c < 48 || 57 < c)",
			"\t{",
			"\t\tif (c == 45)",
			"\t\t\tsgn = 0;",
			"\t\tc = getchar();",
			"\t}",
			"\twhile (47 < c && c < 58)",
			"\t{",
			"\t\tx = (x << 3) + (x << 1) + c - 48;",
			"\t\tc = getchar();",
			"\t}",
			"\treturn sgn ? x : -x;",
			"}",
			"",
			"inline void write(int x) {",
			"\tif (x < 0)",
			"\t\tputchar('-'), x = -x;",
			"\tif (x > 9)",
			"\t\twrite(x / 10);",
			"\tputchar(x % 10 + '0');",
			"}",
			"$0"
		],
		"description": "Log output to console"
	},
	//玄学算法
	"模拟退火": {
		"prefix": "simulate",
		"body": [
			"const double eps = 1e-18;",
			"const double delta = 0.999;",
			"int ans = INT_MAX;",
			"double calc()",
			"{",
			"\t// TODO: 计算当前方案的值",
			"",
			"\tans = min(ans, res);  // 更新全局答案",
			"\treturn res;",
			"}",
			"",
			"void simulate_anneal()  // 模拟退火",
			"{",
			"\tfor (double t = 1e6; t > eps; t *= delta)  // 逐渐降温",
			"\t{",
			"\t\tdouble x = calc();  // 原方案的值",
			"\t\t// TODO: 随机一个新方案",
			"\t\tdouble y = calc();  // 新方案的值",
			"\t\tdouble de = y - x;",
			"",
			"\t\t// 新方案更好，则必选新方案；否则以一定概率选新方案 ",
			"\t\tif (exp(-de / t) > (double)rand() / RAND_MAX)// 一定概率",
			"\t\t{",
			"\t\t\t// TODO: 换成新方案",
			"\t\t}",
			"\t}",
			"}",
			"$0"
		],
		"description": "Log output to console"
	},
	// 4方向偏移量
	"4方向偏移量": {
		"prefix": "int dx",
		"body": [
			"int dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};// 上左下右",
			"$0"
		],
		"description": "Log output to console"
	},
	//8方向偏移量
	"8方向偏移量": {
		"prefix": "int dx",
		"body": [
			"int dx[] = {-1, -1, 0, 1, 1, 1, 0, -1}, dy[] = {0, -1, -1, -1, 0, 1, 1, 1};// 从上为起始逆时针旋转",
			"$0"
		],
		"description": "Log output to console"
	},
	//12方向偏移量
	"12方向偏移量": {
		"prefix": "int dx",
		"body": [
			"int dx[] = {-1, -1, 0, 1, 1, 1, 0, -1, -2, 0, 2, 0}, dy[] = {0, -1, -1, -1, 0, 1, 1, 1, 0, -2, 0, 2};// 从上方逆时针后上下左右",
			"$0"
		],
		"description": "Log output to console"
	},
	//弗洛伊德求最小环
	"弗洛伊德求最小环": {
		"prefix": "floyd",
		"body": [
			"int pos[N][N];  // pos存的是中间点k",
			"int path[N], cnt;  // path 当前最小环的方案, cnt环里面的点的数量",
			"",
			"// 递归处理环上节点",
			"void get_path(int i, int j) {",
			"\tif (pos[i][j] == 0) return;  // i到j的最短路没有经过其他节点",
			"",
			"\tint k = pos[i][j];  // 否则,i ~ k ~ j的话,递归处理 i ~ k的部分和k ~ j的部分",
			"\tget_path(i, k);",
			"\tpath[cnt ++] = k;  // k点放进去",
			"\tget_path(k, j);",
			"}",
			"",
			"void floyd() {// 弗洛伊德求最小环",
			"\tint res = 0x7f7f7f7f;",
			"",
			"\tfor (int k = 1; k <= n; k++) {",
			"\t\tfor (int i = 1; i < k; i++) {",
			"\t\t\tfor (int j = 1; j < i; j++) {",
			"\t\t\t\tif (res > dist[i][j] + d[i][k] + d[k][j]) {",
			"\t\t\t\t\tres = dist[i][j] + d[i][k] + d[k][j];",
			"\t\t\t\t\tcnt = 0;",
			"\t\t\t\t\tpath[cnt ++] = k;  // 先把k放进去",
			"\t\t\t\t\tpath[cnt ++] = i;  // 从k走到i(k固定的)",
			"\t\t\t\t\tget_path(i ,j);  // 递归求i到j的路径",
			"\t\t\t\t\tpath[cnt ++] = j;  // j到k, k固定",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"",
			"\t\tfor (int i = 1; i <= n; i++) {",
			"\t\t\tfor (int j = 1; j <= n; j++) {",
			"\t\t\t\tif (dist[i][j] > dist[i][k] + dist[k][j]) {",
			"\t\t\t\t\tdist[i][j] = dist[i][k] + dist[k][j];  ",
			"\t\t\t\t\tpos[i][j] = k;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"}",
			"$0"
		],
		"description": "Log output to console"
	},
	"kmp求最字符出现位置": {
		"prefix": "kmp",
		"body": [
			"int lenb = b.length()",
			"int lena = a.length()",
			"",
			"for (int i = 2, j = 0; i <= lenb; i++)",
			"{",
			"\twhile (j && b[i] != b[j + 1]) j = ne[j];",
			"\tif (b[i] == b[j + 1]) j++;",
			"\tne[i] = j;",
			"}",
			"for (int i = 1, j = 0; i <= lena; i++)",
			"{",
			"\twhile (j && a[i] != b[j + 1]) j = ne[j];",
			"\tif (a[i] == b[j + 1]) j++;",
			"\tif (j == lenb)",
			"\t{",
			"\t\tcout << i - lenb + 1 << endl;// 如果可以完全匹配，输出第一个字符的位置",
			"\t\tj = ne[j];",
			"\t}",
			"}",
			"$0"
		],
		"description": "Log output to console"
	},
	//--------------------------------------------
	//inv线性求逆元
	"inv线性求逆元": {
		"prefix": "inv",
		"body": [
			"inv[1] = 1;",
			"for(int i = 2;i <= n;i ++)",
			"\tinv[i] = (p - p / i) * inv[p % i] % p;",
		],
		"description": "Log output to console"
	},
	//splay树
	"splay树": {
		"prefix": "splay",
		"body": [
			"struct Node {",
			"\tint s[2], p, v;// 两个儿子、父亲、编号",
			"\tint size;// 节点个数",
			"\t// TODO: 节点额外属性",
			"\t$0",
			"\tvoid init(int _v, int _p) {",
			"\t\tv = _v, p = _p;",
			"\t\tsize = 1;",
			"\t}",
			"}tr[N];",
			"int root, idx;// 根节点、插入时的新编号",
			"",
			"void pushup(int x) {",
			"\ttr[x].size = tr[tr[x].s[0]].size + tr[tr[x].s[1]].size + 1;// 更新子树节点数",
			"\t// TODO: 节点信息上传操作",
			"}",
			"",
			"void pushdown(int x) {",
			"\t// TODO:节点信息下传操作",
			"}",
			"",
			"void rotate(int x) {",
			"\tint y = tr[x].p, z = tr[y].p;// y是x的父亲，z是y的父亲",
			"\tint k = tr[y].s[1] == x;// 如果k为0表示x是y的左儿子，如果k为1表示x是y的右儿子",
			"\ttr[z].s[tr[z].s[1] == y] = x, tr[x].p = z;// z的儿子等于x，x的父亲等于z",
			"\ttr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;// y的另一个儿子，等于x的一个儿子",
			"\ttr[x].s[k ^ 1] = y, tr[y].p = x;// x的一个儿子给了y，那么y就成为x的儿子",
			"\tpushup(y), pushup(x);// x、y的子树信息发生改变，又由于y在x下面，所以先维护y、然后维护x",
			"}",
			"",
			"void splay(int x, int k) {// 把x翻转到k下面，k == 0表示翻转到根",
			"\twhile (tr[x].p != k) {// 如果还没翻转到就继续翻",
			"\t\tint y = tr[x].p, z = tr[y].p;",
			"\t\tif (z != k) {// 如果z不等于k，说明x还要持续往上翻",
			"\t\t\tif ((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);// 如果x和y不是一条链的关系，就先翻x",
			"\t\t\telse rotate(y);// 如果是一条链，就先翻y",
			"\t\t}",
			"\t\trotate(x);// 最后翻一下x",
			"\t}",
			"\tif (!k) root = x;",
			"}",
			"",
			"// 序号左小右大",
			"void insert(int v) {",
			"\tint u = root, p = 0;",
			"\twhile (u) p = u, u = tr[u].s[v > tr[u].v];// 如果v > tr[u].v就往右子树递归",
			"\tu = ++idx;// 找到v应该放的地方，给他一个新的编号",
			"\tif (p) tr[p].s[v > tr[p].v] = u;// 如果有父亲节点，就更新",
			"\ttr[u].init(v, p);// 更新这个节点的信息",
			"\tsplay(u, 0);// 旋转到根",
			"}",
			"",
			"// 寻找第k个数的编号",
			"int get_k(int k) {",
			"\tint u = root;",
			"\twhile (true) {",
			"\t\tpushdown(u);",
			"\t\tif (tr[tr[u].s[0]].size >= k) u = tr[u].s[0];",
			"\t\telse if (tr[tr[u].s[0]].size + 1 == k) return u;",
			"\t\telse k -= tr[tr[u].s[0]].size + 1, u = tr[u].s[1];",
			"\t}",
			"\treturn -1;// 如果没找到",
			"}",
		],
		"description": "Log output to console"
	},
	// 差分
	"差分矩阵": {
		"prefix": "insert",
		"body": [
			"void insert(int x1, int y1, int x2, int y2, int c)",
			"{",
			"\tb[x1][y1] += c;",
			"\tb[x2 + 1][y1] -= c;",
			"\tb[x1][y2 + 1] -= c;",
			"\tb[x2 + 1][y2 + 1] += c;",
			"}",
		],
		"description": "Log output to console"
	},
	// 平板电视平衡树
	"平板电视平衡树": {
		"prefix": "pb_ds",
		"body": [
			"#include<ext/pb_ds/assoc_container.hpp>",
			"#include<ext/pb_ds/tree_policy.hpp>",
			"using namespace __gnu_pbds;",
			"// tree<pii,null_type,less<pii>,rb_tree_tag,tree_order_statistics_node_update> tr;",
			"// pii //存储的类型",
			"// null_type //无映射(低版本g++为null_mapped_type)",
			"// less<pii> //从小到大排序",
			"// rb_tree_tag //红黑树",
			"// tree_order_statistics_node_update //更新方式 ",
			"// tr.insert(mp(x,y)); //插入;",
			"// tr.erase(mp(x,y)); //删除;",
			"// tr.order_of_key(pii(x,y)); //求排名 从0开始",
			"// tr.find_by_order(x); //找k小值，返回迭代器 从0开始 ",
			"// tr.join(b); //将b并入tr，前提是两棵树类型一样且没有重复元素 ",
			"// tr.split(v,b); //分裂，key小于等于v的元素属于tr，其余的属于b",
			"// tr.lower_bound(x); //返回第一个大于等于x的元素的迭代器",
			"// tr.upper_bound(x); //返回第一个大于x的元素的迭代器",
			"// 以上所有操作的时间复杂度均为O(logn) ",
		],
		"description": "Log output to console"
	},
	// 可持久化线段树（主席树hjt）单点修改单点查询
	"可持久化单点修改单点查询": {
		"prefix": "build",
		"body": [
			"struct Node",
			"{",
			"\tint l, r;",
			"\t// TODO: 需要维护的信息和懒标记",
			"\tint v;",
			"} tr[N * 24];// 初始需要4n的空间存，之后开点需要longn倍",
			"int a[N], top, n, root[N];// 原数组、当前结点编号、数组长度、版本编号",
			"",
			"int clone(int ver)",
			"{",
			"\ttr[++top] = tr[ver]; //全部信息都传到新节点",
			"\treturn top;",
			"}",
			"",
			"int build(int ver = 0, int l = 1, int r = n)// root[0] = build() 建立初始线段树的状态",
			"{",
			"\tver = ++top;",
			"\tif (l == r)",
			"\t{",
			"\t\ttr[ver].v = a[l];",
			"\t\treturn top;",
			"\t}",
			"\tint mid = l + r >> 1;",
			"\ttr[ver].l = build(tr[ver].l, l, mid);",
			"\ttr[ver].r = build(tr[ver].r, mid + 1, r);",
			"\treturn ver;",
			"}",
			"",
			"int update(int ver, int x, int val, int l = 1, int r = n) // 将第ver版本的a[x] 修改为 val",
			"{",
			"\tver = clone(ver);",
			"\tif (l == r) tr[ver].v = val;",
			"\telse",
			"\t{",
			"\t\tint mid = l + r >> 1;",
			"\t\tif (x <= mid) tr[ver].l = update(tr[ver].l, x, val, l, mid);",
			"\t\telse tr[ver].r = update(tr[ver].r, x, val, mid + 1, r);",
			"\t}",
			"\treturn ver;",
			"}",
			"",
			"int query(int ver, int x, int l = 1, int r = n)// 查询ver版本的第x个数",
			"{",
			"\tif (l == r) return tr[ver].v;",
			"\telse",
			"\t{",
			"\t\tint mid = l + r >> 1;",
			"\t\tif (x <= mid) return query(tr[ver].l, x, l, mid);",
			"\t\telse return query(tr[ver].r, x, mid + 1, r);",
			"\t}",
			"}",
		],
		"description": "Log output to console"
	},
	// 主席树查询区间k小数（离线）
	"查询区间K小数(离线)": {
		"prefix": "build",
		"body": [
			"struct Node",
			"{",
			"\tint l, r;",
			"\t// TODO: 需要维护的信息和懒标记",
			"\tint sum;// 该区间有多少个点",
			"} tr[N * 24];// 初始需要4n的空间存，之后开点需要longn倍",
			"int a[N], top, root[N];// 原数组、当前结点编号、版本编号",
			"",
			"int clone(int ver)",
			"{",
			"\ttr[++top] = tr[ver]; //全部信息都传到新节点",
			"\treturn top;",
			"}",
			"",
			"int build(int ver, int l, int r)// root[0] = build() 建立初始线段树的状态",
			"{",
			"\tver = ++top;",
			"\tif (l == r)",
			"\t{",
			"\t\treturn ver;",
			"\t}",
			"\tint mid = l + r >> 1;",
			"\ttr[ver].l = build(tr[ver].l, l, mid);",
			"\ttr[ver].r = build(tr[ver].r, mid + 1, r);",
			"\treturn ver;",
			"}",
			"",
			"int update(int pre, int x, int l, int r) // 在前一个版本的基础上，添加x这个数，并更新结点",
			"{",
			"\tint rt = clone(pre);// 将前一个版本的值先赋给当前版本",
			"\ttr[rt].sum ++;// x在该区间，所以当前版本总和加一",
			"\tif (l == r) return rt;",
			"\telse",
			"\t{",
			"\t\tint mid = l + r >> 1;",
			"\t\tif (x <= mid) tr[rt].l = update(tr[pre].l, x, l, mid);",
			"\t\telse tr[rt].r = update(tr[pre].r, x, mid + 1, r);",
			"\t}",
			"\treturn rt;",
			"}",
			"",
			"int query(int u, int v, int k, int l, int r)// 查询(u + 1)->v版本之间第k小数（区间[u + 1, v]）",
			"{",
			"\tint x = tr[tr[v].l].sum - tr[tr[u].l].sum;",
			"\tif (l == r) return l;",
			"\telse",
			"\t{",
			"\t\tint mid = l + r >> 1;",
			"\t\tif (x >= k) return query(tr[u].l, tr[v].l, k, l, mid);",
			"\t\telse return query(tr[u].r, tr[v].r, k - x, mid + 1, r);",
			"\t}",
			"}",
		],
		"description": "Log output to console"
	},
	// 线性基
	"线性基": {
		"prefix": "Linear_base",
		"body": [
			"namespace Linear_base {",
			"\tll ba[61], temp[61];",
			"\tbool flag;",
			"\tvoid insert(ll x) {",
			"\t\tfor (int i = 60;i >= 0; i--)",
			"\t\t\tif (x & (1ll << i))",
			"\t\t\t\tif (!ba[i]) {",
			"\t\t\t\t\tba[i] = x;",
			"\t\t\t\t\treturn;",
			"\t\t\t\t}",
			"\t\t\telse x ^= ba[i];",
			"\t\tflag = true;",
			"\t}",
			"\tbool check(ll x) {",
			"\t\tfor (int i = 60; i >= 0; i--)",
			"\t\t\tif (x & (1ll << i))",
			"\t\t\t\tif (!ba[i]) return false;",
			"\t\t\t\telse x ^= ba[i];",
			"\t\treturn true;",
			"\t}",
			"\tll qmax(ll res = 0) {",
			"\t\tfor (int i = 60;i >= 0; i--)",
			"\t\t\tres = max(res, res ^ ba[i]);",
			"\t\treturn res;",
			"\t}",
			"\tll qmin() {",
			"\t\tif (flag) return 0;",
			"\t\tfor (int i = 0; i <= 60; i++)",
			"\t\t\tif (ba[i]) return ba[i];",
			"\t\treturn -1;",
			"\t}",
			"\tll query(ll k) {",
			"\t\tll res = 0;",
			"\t\tint cnt = 0;",
			"\t\tk -= flag;",
			"\t\tif (!k) return 0;",
			"\t\tfor (int i = 0; i <= 60; i++)",
			"\t\t{",
			"\t\t\tfor (int j = i - 1; ~j; j--)",
			"\t\t\t\tif (ba[i] & (1ll << j)) ba[i] ^= ba[j];",
			"\t\t\tif (ba[i]) temp[cnt++] = ba[i];",
			"\t\t}",
			"\t\tif (k >= (1ll << cnt)) return -1;",
			"\t\tfor (int i = 0; i < cnt; i++)",
			"\t\t\tif (k & (1ll << i)) res ^= temp[i];",
			"\t\treturn res;",
			"\t}",
			"}",
		],
		"description": "Log output to console"
	},
	// "": {
	// 	"prefix": "log",
	// 	"body": [],
	// 	"description": "Log output to console"
	// },
	// "": {
	// 	"prefix": "log",
	// 	"body": [],
	// 	"description": "Log output to console"
	// },
}
```

