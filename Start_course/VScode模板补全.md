

| 模板                       | 快捷键            |
| -------------------------- | ----------------- |
| 常用const                  | `const`           |
| typdef                     | `typedef`         |
| 常用头文件                 | `#incl`           |
| 常用using                  | `us`              |
| 常用main                   | `main`            |
| memset初始化各种数组       | `memset`          |
| 快速幂                     | `ksm`             |
| 拓展欧几里得算法           | `exgcd`           |
| 欧拉筛质数                 | `ola`             |
| 字典树插入字符串求出现次数 | `insert`          |
| 并查集                     | `find`            |
| 加边函数不带权             | `add`             |
| 加边函数带权               | `add`             |
| 优先队列dijkstra           | `dijkstra`        |
| spfa判断是否有环           | `bool spfa`       |
| lowbit求最低位1            | `lowbit`          |
| lowbit树状数组             | `lowbit`          |
| 线段树                     | `build`           |
| AC自动机简单版             | `ac`              |
| AC自动机加强版             | `ac`              |
| manacher                   | `manacher`        |
| Lucas定理求组合数          | `lucas`           |
| min25筛                    | `min25`           |
| 杜教筛                     | `dujiao`          |
| 递归排序                   | `mer`             |
| topsort拓扑排序            | `topsort`         |
| 倍增lca求两点距离          | `lca`             |
| 倍增lca求最近公共祖先      | `lca`             |
| tarjan算法求割点           | `tarjan`          |
| tarjan强连通分量           | `tarjan`          |
| add - 高精度加法           | `vector<int> add` |
| sub - 高精度减法           | `vector<int> sub` |
| mul - 高精度乘低精度       | `vector<int> mul` |
| div - 高精度除以低精度     | `vector<int> div` |
|                            |                   |
|                            |                   |
|                            |                   |
|                            |                   |
|                            |                   |
|                            |                   |

```cpp
{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	//常用const
	"const": {
		"prefix": "const",
		"body": [
			"const int N = 1e5 + 10, M = 2e5 + 10, mod = 1331;"
		],
		"description": "Log output to console"
	},
	//typedef
	"常用typedef": {
		"prefix": "typedef",
		"body": [
			"typedef long long ll;",
			"typedef pair<int, int> PII;",
			"typedef pair<int, PII> PIII;"
		],
		"description": "Log output to console"
	},
	//常用头文件
	"#include": {
		"prefix": "#incl",
		"body": [
			"#include <iostream>",
			"#include <cstring>",
			"#include <algorithm>"
		],
		"description": "Log output to console"
	},
	//常用using
	"#using namespace std": {
		"prefix": "us",
		"body": [
			"using namespace std;"
		],
		"description": "Log output to console"
	},
	//常用main
	"main主函数": {
		"prefix": "main",
		"body": [
			"int main()",
			"{",
			"\tfreopen(\"in.in\", \"r\", stdin);",
			"\tfreopen(\"out.out\", \"w\", stdout);",
			"",
			"\treturn 0;",
			"}"
		],
		"description": "Log output to console"
	},
	//快速幂
	"快速幂": {
		"prefix": "ksm",
		"body": [
			"ll ksm(ll a, ll b)",
			"{",
			"\tll res = 1ll;",
			"\twhile (b)",
			"\t{",
			"\t\tif (b & 1)",
			"\t\t\tres = (res * a) % mod;",
			"\t\ta = (a * a) % mod;",
			"\t\tb >>= 1;",
			"\t}",
			"\treturn res;",
			"}"
		],
		"description": "Log output to console"
	},
	//lowbit
	"最低位1": {
		"prefix": "lowbit",
		"body": [
			"int lowbit(int x) {",
			"\treturn x & -x;",
			"}"
		],
		"description": "Log output to console"
	},
	//lowbit树状数组
	"树状数组": {
		"prefix": "lowbit",
		"body": [
			"int lowbit(int x)",
			"{",
			"\treturn x & -x;",
			"}",
			"",
			"void update(int x, int c)  // 位置x加c",
			"{",
			"\tfor (int i = x;i <= n; i += lowbit(i)) tr[i] += c;",
			"}",
			"",
			"int getsum(int x)  // 返回前x个数的和",
			"{",
			"\tint res = 0;",
			"\tfor (int i = x;i > 0; i -= lowbit(i)) res += tr[i];",
			"\treturn res;",
			"}",
		],
		"description": "Log output to console"
	},
	//线段树
	"线段树": {
		"prefix": "build",
		"body": [
			"struct Node",
			"{",
			"\tint l, r;",
			"\t// TODO: 需要维护的信息和懒标记",
			"}tr[N * 4];",
			"",
			"void pushup(int u)",
			"{",
			"\t// TODO: 利用左右儿子信息维护当前节点的信息",
			"}",
			"",
			"void pushdown(int u)",
			"{",
			"\t// TODO: 将懒标记下传",
			"}",
			"",
			"void build(int u = 1, int l = 1, int r = n)",
			"{",
			"\ttr[u] = {l, r};",
			"\tif (l == r) {",
			"",
			"\t}",
			"\telse",
			"\t{",
			"\t\tint mid = l + r >> 1;",
			"\t\tbuild(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);",
			"\t\tpushup(u);",
			"\t}",
			"}",
			"",
			"void update(int l, int r, int d, int u = 1)",
			"{",
			"\tif (tr[u].l >= l && tr[u].r <= r)",
			"\t{",
			"\t\t// TODO: 修改区间",
			"\t}",
			"\telse",
			"\t{",
			"\t\tpushdown(u);",
			"\t\tint mid = tr[u].l + tr[u].r >> 1;",
			"\t\tif (l <= mid) update(l, r, d, u << 1);",
			"\t\tif (r > mid) update(l, r, d, u << 1 | 1);",
			"\t\tpushup(u);",
			"\t}",
			"}",
			"",
			"int query(int l, int r, int u = 1)",
			"{",
			"\tif (tr[u].l >= l && tr[u].r <= r)",
			"\t{",
			"\t\treturn ;  // TODO 需要补充返回值",
			"\t}",
			"\telse",
			"\t{",
			"\t\tpushdown(u);",
			"\t\tint mid = tr[u].l + tr[u].r >> 1;",
			"\t\tint res = 0;",
			"\t\tif (l <= mid ) res = query(l, r, u << 1);",
			"\t\tif (r > mid) res += query(l, r, u << 1 | 1);",
			"\t\treturn res;",
			"\t}",
			"}"
		],
		"description": "Log output to console"
	},
	//AC简单版
	"AC简单版": {
		"prefix": "ac",
		"body": [
			"namespace AC{",
			"\tint tr[N][26], fail[N], e[N], tot;",
			"",
			"\tvoid insert(char *s){",
			"\t\tint u = 0;",
			"\t\tfor(int i = 1;s[i];i++){",
			"\t\t\tif(!tr[u][s[i] - 'a']) tr[u][s[i] - 'a'] = ++tot;",
			"\t\t\tu = tr[u][s[i] - 'a'];",
			"\t\t}",
			"\t\te[u]++;",
			"\t}",
			"",
			"\tqueue<int> q;",
			"\tvoid build(){",
			"\t\tfor(int i = 0;i < 26;i++){",
			"\t\t\tif(tr[0][i]) q.push(tr[0][i]);",
			"\t\t}",
			"\t\twhile(q.size()){",
			"\t\t\tint u = q.front();",
			"\t\t\tq.pop();",
			"\t\t\tfor(int i = 0;i < 26;i++){",
			"\t\t\t\tif(tr[u][i]){",
			"\t\t\t\t\tfail[tr[u][i]] = tr[fail[u]][i];",
			"\t\t\t\t\tq.push(tr[u][i]);",
			"\t\t\t\t}",
			"\t\t\t\telse tr[u][i] = tr[fail[u]][i];",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"\tint query(char *t){",
			"\t\tint u = 0, res = 0;",
			"\t\tfor(int i = 1;t[i];i++){",
			"\t\t\tu = tr[u][t[i] - 'a'];",
			"\t\t\tfor(int j = u;j && ~e[j];j = fail[j]){",
			"\t\t\t\tres += e[j];",
			"\t\t\t\te[j] = -1;",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"}"
		],
		"description": "Log output to console"
	},
	//AC加强版
	"AC加强版": {
		"prefix": "ac",
		"body": [
			"namespace AC{",
			"\tint tr[M][26], fail[M], e[M], tot;//字典树 指针 标号",
			"\tint cnt[N], val[M];",
			"\tvoid init(){",
			"\t\tmemset(tr, 0, sizeof tr);",
			"\t\tmemset(fail, 0, sizeof fail);",
			"\t\tmemset(e, 0, sizeof e);",
			"\t\tmemset(cnt, 0, sizeof cnt);",
			"\t\tmemset(val, 0, sizeof val);",
			"\t\ttot = 0;",
			"\t}",
			"\tvoid insert(char *s, int id){",
			"\t\tint u = 0;",
			"\t\tfor(int i = 1;s[i];i++){",
			"\t\t\tif(!tr[u][s[i] - 'a']) tr[u][s[i] - 'a'] = ++tot;",
			"\t\t\tu = tr[u][s[i] - 'a'];",
			"\t\t}",
			"\t\te[u] = id;",
			"\t}",
			"\tqueue<int> q;",
			"\tvoid build(){",
			"\t\tfor(int i = 0;i < 26;i++)",
			"\t\t\tif(tr[0][i]) q.push(tr[0][i]);",
			"\t\twhile(q.size()){",
			"\t\t\tint u = q.front();",
			"\t\t\tq.pop();",
			"\t\t\tfor(int i = 0; i < 26;i++){",
			"\t\t\t\tif(tr[u][i]){",
			"\t\t\t\t\tfail[tr[u][i]] = tr[fail[u]][i];",
			"\t\t\t\t\tq.push(tr[u][i]);",
			"\t\t\t\t}else tr[u][i] = tr[fail[u]][i];",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"\tint query(char *t){",
			"\t\tint u = 0, res = 0;",
			"\t\tfor(int i = 1;t[i];i++){",
			"\t\t\tu = tr[u][t[i] - 'a'];",
			"\t\t\tfor(int j = u;j;j = fail[j]) val[j]++;",
			"\t\t}",
			"\t\tfor(int i = 1;i <= tot;i++){",
			"\t\t\tif(e[i]){",
			"\t\t\t\tres = max(res, val[i]);",
			"\t\t\t\tcnt[e[i]] = val[i];",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"}"
		],
		"description": "Log output to console"
	},
	//字符串马拉车
	"manacher马拉车": {
		"prefix": "manacher",
		"body": [
			"int str[N], nstr[2 * N], len[2 * N];",
			"",
			"int init(int len)//返回字符串长度、len为原长度、str为字符串、nstr为新字符串",
			"{",
			"\tint j = 2;",
			"\tnstr[0] = '@', nstr[1] = '#';",
			"\tfor (int i = 0; i < len; i++)",
			"\t{",
			"\t\tnstr[j++] = str[i];",
			"\t\tnstr[j++] = '#';",
			"\t}",
			"\tnstr[j] = '*';",
			"\treturn j;",
			"}",
			"",
			"int man(int len)//返回最长字符串、len为字符串长度",
			"{",
			"\tint mx = 0, id = 1, max_len = 0;",
			"\tfor (int i = 1; i < len; i++)",
			"\t{",
			"\t\tlens[i] = i < mx ? min(mx - i, lens[2 * id - i]) : 1;",
			"\t\twhile (nstr[i + lens[i]] == nstr[i - lens[i]])",
			"\t\t\tlens[i]++;",
			"\t\tif (lens[i] + i > mx)",
			"\t\t{",
			"\t\t\tmx = lens[i] + i;",
			"\t\t\tid = i;",
			"\t\t}",
			"\t\tmax_len = max(max_len, lens[i]);",
			"\t}",
			"\treturn max_len - 1;",
			"}"
		],
		"description": "Log output to console"
	},
	//Lucas定理
	"Lucas定理": {
		"prefix": "lucas",
		"body": [
			"int qmi(int a, int k, int p)  // 快速幂模板",
			"{",
			"\tint res = 1 % p;",
			"\twhile (k)",
			"\t{",
			"\t\tif (k & 1) res = (ll)res * a % p;",
			"\t\ta = (ll)a * a % p;",
			"\t\tk >>= 1;",
			"\t}",
			"\treturn res;",
			"}",
			"",
			"int C(int a, int b, int p)  // 通过定理求组合数C(a, b)",
			"{",
			"\tif (a < b) return 0;",
			"",
			"\tll x = 1, y = 1;  // x是分子，y是分母",
			"\tfor (int i = a, j = 1; j <= b; i --, j ++ )",
			"\t{",
			"\t\tx = (ll)x * i % p;",
			"\t\ty = (ll) y * j % p;",
			"\t}",
			"",
			"\treturn x * (ll)qmi(y, p - 2, p) % p;",
			"}",
			"",
			"int lucas(ll a, ll b, int p)",
			"{",
			"\tif (a < p && b < p) return C(a, b, p);",
			"\treturn (ll)C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;",
			"}",
		],
		"description": "Log output to console"
	},
	//min25筛
	"min25筛": {
		"prefix": "min25",
		"body": [
			"inline ll FUN(ll v, ll N, ll nd, ll nv) { return v >= nd ? (N / v - 1) : (nv - v); }",
			"ll PrimeSum(ll N)",
			"{",
			"\tll *S, *V, r = (ll)sqrt(N);",
			"\tll nd = N / r;",
			"\tll nv = r + nd - 1;",
			"\tV = new ll[nv], S = new ll[nv];",
			"\tfor (ll i = 0; i < r; i++)",
			"\t\tV[i] = N / (i + 1);",
			"\tfor (ll i = r; i < nv; i++)",
			"\t\tV[i] = V[i - 1] - 1;",
			"\tfor (ll i = 0; i < nv; i++)",
			"\t\tS[i] = V[i] * (V[i] + 1) / 2 - 1;",
			"\tfor (ll p = 2; p <= r; p++)",
			"\t{",
			"\t\tif (S[nv - p] > S[nv - p + 1])",
			"\t\t{",
			"\t\t\tll sp = S[nv - p + 1];",
			"\t\t\tll p2 = p * p;",
			"\t\t\tfor (ll i = 0; i < nv; i++)",
			"\t\t\t{",
			"\t\t\t\tif (V[i] >= p2)",
			"\t\t\t\t\tS[i] -= p * (S[FUN(V[i] / p, N, nd, nv)] - sp);",
			"\t\t\t\telse",
			"\t\t\t\t\tbreak;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\treturn S[0];",
			"}"
		],
		"description": "Log output to console"
	},
	//杜教筛 dujiao
	"杜教筛": {
		"prefix": "dujiao",
		"body": [
			"typedef long long ll;",
			"const int mod = 1000000007;",
			"const int maxn = 5000000;",
			"ll pai[maxn + 5];",
			"int prim[maxn + 5], cnt, mu[maxn + 5];",
			"bool vis[maxn + 5];",
			"unordered_map<int, int> ans_mu;",
			"unordered_map<int, ll> ans_pai;",
			"void init()",
			"{",
			"\tmu[1] = pai[1] = 1;",
			"\tfor (int i = 2; i <= maxn; ++i)",
			"\t{",
			"\t\tif (!vis[i])",
			"\t\t\tprim[++cnt] = i, mu[i] = -1, pai[i] = i - 1;",
			"\t\tfor (int j = 1; j <= cnt && prim[j] * i <= maxn; ++j)",
			"\t\t{",
			"\t\t\tvis[prim[j] * i] = 1;",
			"\t\t\tif (i % prim[j] == 0)",
			"\t\t\t{",
			"\t\t\t\tpai[i * prim[j]] = pai[i] * prim[j];",
			"\t\t\t\tbreak;",
			"\t\t\t}",
			"\t\t\tpai[i * prim[j]] = pai[prim[j]] * pai[i];",
			"\t\t\tmu[i * prim[j]] = -mu[i];",
			"\t\t}",
			"\t}",
			"\tfor (int i = 1; i <= maxn; ++i)",
			"\t\tmu[i] += mu[i - 1], pai[i] += pai[i - 1];",
			"}",
			"//φ前缀和",
			"ll get_pai(ll x)",
			"{",
			"\tif (x <= maxn)",
			"\t\treturn pai[x];",
			"\tif (ans_pai[x])",
			"\t\treturn ans_pai[x];",
			"\tll ans = ((1ll + x) * x) / 2ll;",
			"\tfor (int l = 2, r; l <= x; l = r + 1)",
			"\t{",
			"\t\tr = x / (x / l);",
			"\t\tans -= 1ll * (r - l + 1) * get_pai(x / l);",
			"\t}",
			"\treturn ans_pai[x] = ans;",
			"}",
			"//i * φ前缀和",
			"ll get_piai(ll x)",
			"{",
			"\tif (x <= maxn)",
			"\t\treturn pai[x];",
			"\tif (ans_pai[x])",
			"\t\treturn ans_pai[x];",
			"\tll ans = x * (x + 1ll) * (2ll * x + 1ll) / (ll)6;",
			"\tfor (int l = 2, r; l <= x; l = r + 1)",
			"\t{",
			"\t\tr = x / (x / l);",
			"\t\tans -= 1ll * (r - l + 1) * get_piai(x / l);",
			"\t}",
			"\treturn ans_pai[x] = ans;",
			"}",
			"//μ前缀和",
			"int get_mu(int x)",
			"{",
			"\tif (x <= maxn)",
			"\t\treturn mu[x];",
			"\tif (ans_mu[x])",
			"\t\treturn ans_mu[x];",
			"\tint ans = 1;",
			"\tfor (int l = 2, r; l <= x; l = r + 1)",
			"\t{",
			"\t\tr = x / (x / l);",
			"\t\tans -= (r - l + 1) * get_mu(x / l);",
			"\t}",
			"\treturn ans_mu[x] = ans;",
			"}",
			"//i * μ前缀和",
			"int get_miu(int x)",
			"{",
			"\tif (x <= maxn)",
			"\t\treturn mu[x];",
			"\tif (ans_mu[x])",
			"\t\treturn ans_mu[x];",
			"\tint ans = 1;",
			"\tfor (int l = 2, r; l <= x; l = r + 1)",
			"\t{",
			"\t\tr = x / (x / l);",
			"\t\tans -= (r - l + 1) * l * get_miu(x / l);",
			"\t}",
			"\treturn ans_mu[x] = ans;",
			"}",
			"void doit()",
			"{",
			"\tint T = read();",
			"\twhile (T--)",
			"\t{",
			"\t\tint x = read();",
			"\t\t//TODO:选择要输出的",
			"\t}",
			"}"
		],
		"description": "Log output to console"
	},
	//递归排序
	"递归排序": {
		"prefix": "mer",
		"body": [
			"void merge_sort(int q[], int l, int r)  // 归并排序",
			"{",
			"\tif (l >= r) return;",
			"",
			"\tint mid = l + r >> 1;",
			"\tmerge_sort(q, l, mid);",
			"\tmerge_sort(q, mid + 1, r);",
			"",
			"\tint k = 0, i = l, j = mid + 1;",
			"\twhile (i <= mid && j <= r)",
			"\t\tif (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];",
			"\t\telse tmp[k ++ ] = q[j ++ ];",
			"",
			"\twhile (i <= mid) tmp[k ++ ] = q[i ++ ];",
			"\twhile (j <= r) tmp[k ++ ] = q[j ++ ];",
			"",
			"\tfor (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];",
			"}",
		],
		"description": "Log output to console"
	},
	//topsort拓扑排序
	"拓扑排序": {
		"prefix": "topsort",
		"body": [
			"bool topsort()",
			"{",
			"\tint hh = 0, tt = -1;",
			"",
			"\t// d[i] 存储点i的入度",
			"\tfor (int i = 1; i <= n; i ++ )",
			"\t\tif (!d[i])",
			"\t\t\tq[ ++ tt] = i;",
			"",
			"\twhile (hh <= tt)",
			"\t{",
			"\t\tint t = q[hh ++ ];",
			"",
			"\t\tfor (int i = h[t]; i != -1; i = ne[i])",
			"\t\t{",
			"\t\t\tint j = e[i];",
			"\t\t\tif (-- d[j] == 0)",
			"\t\t\t\tq[ ++ tt] = j;",
			"\t\t}",
			"\t}",
			"",
			"\t// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。",
			"\treturn tt == n - 1;",
			"}",
		],
		"description": "Log output to console"
	},
	//最近公共祖先
	"倍增lca求两点距离": {
		"prefix": "lca",
		"body": [
			"//存图",
			"int h[N], e[M], ne[M], w[M], idx;",
			"//fa[u][i]表示u的第2^i个祖先,dist[u][i]表示u到第2^i个祖先的距离,dep[u]表示u的深度",
			"int fa[N][31], dist[N][31], dep[N];",
			"",
			"inline void add (int a, int b, int c) {",
			"\te[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;",
			"}",
			"",
			"void dfs (int u, int father) {",
			"\tfa[u][0] = father;//当前点的第2^0个祖先就是我的父亲",
			"\tdep[u] = dep[fa[u][0]] + 1;//当前点的深度就是父亲的深度 + 1",
			"",
			"\tfor (int i = 1;i < 31;i ++) {",
			"\t\t//u的第2^i个祖先,就是第2^(i - 1)个祖先的第2^(i - 1)个祖先",
			"\t\tfa[u][i] = fa[fa[u][i - 1]][i - 1];",
			"\t\t//u到第2^i个祖先的距离就是u到第2^(i - 1)个祖先的距离加上第2^(i - 1)个祖先到他的2^(i - 1)个祖先的距离",
			"\t\tdist[u][i] = dist[u][i - 1] + dist[fa[u][i - 1]][i - 1];",
			"\t}",
			"",
			"\tfor (int i = h[u];~i;i = ne[i]) {//遍历子节点",
			"\t\tint j = e[i];",
			"\t\tif (j == father) continue;",
			"\t\tdist[j][0] = w[i];",
			"\t\tdfs(j, u);",
			"\t}",
			"}",
			"",
			"int lca (int x, int y) {",
			"\tint res = 0;",
			"",
			"\tif(dep[x] > dep[y]) swap(x, y);//令y为深度大的点",
			"",
			"\tint tmp = dep[y] - dep[x];//得到深度差",
			"\tfor (int j = 0;tmp;j ++, tmp >>= 1) {//二进制递减深度",
			"\t\tif(tmp & 1) res += dist[y][j], y = fa[y][j];",
			"\t}",
			"",
			"\tif (x == y) return res;//如果x == y,证明x和y在同一个小子树上，直接返回结果",
			"",
			"\t//如果不在一个小子树上,继续往上找",
			"\tfor (int i = 30;i >= 0;i --) {//这里从上往下，使得x和y到距离最近公共祖先最近的点",
			"\t\tif (fa[x][i] != fa[y][i]) {",
			"\t\t\tres += dist[x][i] + dist[y][i];",
			"\t\t\tx = fa[x][i];",
			"\t\t\ty = fa[y][i];",
			"\t\t}",
			"\t}",
			"",
			"\tres += dist[x][0] + dist[y][0];//最后把从x和y到最近公共祖先的距离也加上",
			"",
			"\treturn res;",
			"}",
		],
		"description": "Log output to console"
	},
	//最近公共祖先
	"倍增lca求最近公共祖先": {
		"prefix": "lca",
		"body": [
			"//存图",
			"int h[N], e[M], ne[M], idx;",
			"//fa[u][i]表示u的第2^i个祖先,dist[u][i]表示u到第2^i个祖先的距离,dep[u]表示u的深度",
			"int fa[N][31], dist[N][31], dep[N];",
			"",
			"inline void add (int a, int b) {",
			"\te[idx] = b, ne[idx] = h[a], h[a] = idx++;",
			"}",
			"",
			"void dfs (int u, int father) {",
			"\tfa[u][0] = father;//当前点的第2^0个祖先就是我的父亲",
			"\tdep[u] = dep[fa[u][0]] + 1;//当前点的深度就是父亲的深度 + 1",
			"",
			"\tfor (int i = 1;i < 31;i ++) {",
			"\t\tfa[u][i] = fa[fa[u][i - 1]][i - 1];//u的第2^i个祖先,就是第2^(i - 1)个祖先的第2^(i - 1)个祖先",
			"\t}",
			"",
			"\tfor (int i = h[u];~i;i = ne[i]) {//遍历子节点",
			"\t\tint j = e[i];",
			"\t\tif (j == father) continue;",
			"\t\tdfs(j, u);",
			"\t}",
			"}",
			"",
			"int lca (int x, int y) {",
			"",
			"\tif(dep[x] > dep[y]) swap(x, y);//令y为深度大的点",
			"",
			"\tint tmp = dep[y] - dep[x];//得到深度差",
			"\tfor (int j = 0;tmp;j ++, tmp >>= 1) {//二进制递减深度",
			"\t\tif(tmp & 1) y = fa[y][j];",
			"\t}",
			"",
			"\tif (x == y) return x;",
			"",
			"\t//如果不在一个小子树上,继续往上找",
			"\tfor (int i = 30;i >= 0;i --) {//这里从上往下，使得x和y到距离最近公共祖先最近的点",
			"\t\tif (fa[x][i] != fa[y][i]) {",
			"\t\t\tx = fa[x][i];",
			"\t\t\ty = fa[y][i];",
			"\t\t}",
			"\t}",
			"",
			"\treturn fa[x][0];",
			"}",
		],
		"description": "Log output to console"
	},
	//自带数组
	"加边函数不带权": {
		"prefix": "add",
		"body": [
			"int h[N], e[M], ne[M], idx;",
			"void add(int a, int b)  // 添加一条边a->b",
			"{",
			"\te[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;",
			"}",
		],
		"description": "Log output to console"
	},
	//自带数组
	"加边函数带权": {
		"prefix": "add",
		"body": [
			"int h[N], e[M], ne[M], w[M], idx;",
			"void add(int a, int b, int c)  // 添加一条边a->b，边权为c",
			"{",
			"\te[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;",
			"}",
		],
		"description": "Log output to console"
	},
	//memset初始化h数组
	"初始化h数组": {
		"prefix": "memset",
		"body": [
			"memset(h, -1, sizeof h);"
		],
		"description": "Log output to console"
	},
	// memset初始化st数组
	"初始化st数组": {
		"prefix": "memset",
		"body": [
			"memset(st, 0, sizeof st);"
		],
		"description": "Log output to console"
	},
	// memset初始化dis数组
	"初始化dis数组": {
		"prefix": "memset",
		"body": [
			"memset(dis, 127, sizeof dis);"
		],
		"description": "Log output to console"
	},
	//拓展欧几里得算法
	"拓展欧几里得算法": {
		"prefix": "exgcd",
		"body": [
			"int exgcd(int a, int b, int &x, int &y)  // 扩展欧几里得算法, 求x, y，使得ax + by = gcd(a, b)",
			"{",
			"\tif (!b)",
			"\t{",
			"\t\tx = 1; y = 0;",
			"\t\treturn a;",
			"\t}",
			"\tint d = exgcd(b, a % b, y, x);",
			"\ty -= (a / b) * x;",
			"\treturn d;",
			"}",
		],
		"description": "Log output to console"
	},
	//优化并查集
	"并查集": {
		"prefix": "find",
		"body": [
			"int find(int x)  // 并查集",
			"{",
			"\tif (fa[x] != x) fa[x] = find(fa[x]);",
			"\treturn fa[x];",
			"}",
		],
		"description": "Log output to console"
	},
	//字典树插入字符串
	"字典树插入字符串求出现次数": {
		"prefix": "insert",
		"body": [
			"int son[N][26], cnt[N], idx;",
			"",
			"void insert(char *str)  // 插入字符串",
			"{",
			"\tint p = 0;",
			"\tfor (int i = 0; str[i]; i ++ )",
			"\t{",
			"\t\tint u = str[i] - 'a';",
			"\t\tif (!son[p][u]) son[p][u] = ++ idx;",
			"\t\tp = son[p][u];",
			"\t}",
			"\tcnt[p] ++ ;",
			"}",
			"",
			"int query(char *str)  // 查询字符串出现次数",
			"{",
			"\tint p = 0;",
			"\tfor (int i = 0; str[i]; i ++ )",
			"\t{",
			"\t\tint u = str[i] - 'a';",
			"\t\tif (!son[p][u]) return 0;",
			"\t\tp = son[p][u];",
			"\t}",
			"\treturn cnt[p];",
			"}",
		],
		"description": "Log output to console"
	},
	//优先队列dijkstra
	"优先队列1-n最短路": {
		"prefix": "dijkstra",
		"body": [
			"void dijkstra()  // 求1号点到n号点的最短路距离",
			"{",
			"\tmemset(dist, 0x3f, sizeof dist);",
			"\tdist[1] = 0;",
			"\tpriority_queue<PII, vector<PII>, greater<PII>> heap;",
			"\theap.push({0, 1});",
			"",
			"\twhile (heap.size())",
			"\t{",
			"\t\tauto t = heap.top();",
			"\t\theap.pop();",
			"",
			"\t\tint ver = t.second, distance = t.first;",
			"",
			"\t\tif (st[ver]) continue;",
			"\t\tst[ver] = true;",
			"",
			"\t\tfor (int i = h[ver]; i != -1; i = ne[i])",
			"\t\t{",
			"\t\t\tint j = e[i];",
			"\t\t\tif (dist[j] > dist[ver] + w[i])",
			"\t\t\t{",
			"\t\t\t\tdist[j] = dist[ver] + w[i];",
			"\t\t\t\theap.push({dist[j], j});",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"}",
		],
		"description": "Log output to console"
	},
	//add - 高精度加法
	"add - 高精度加法": {
		"prefix": "vector<int> add",
		"body": [
			"vector<int> add(vector<int> &A, vector<int> &B)  // C = A + B, A >= 0, B >= 0",
			"{",
			"\tif (A.size() < B.size()) return add(B, A);",
			"",
			"\tvector<int> C;",
			"\tint t = 0;",
			"\tfor (int i = 0; i < A.size(); i ++ )",
			"\t{",
			"\t\tt += A[i];",
			"\t\tif (i < B.size()) t += B[i];",
			"\t\tC.push_back(t % 10);",
			"\t\tt /= 10;",
			"\t}",
			"",
			"\tif (t) C.push_back(t);",
			"\treturn C;",
			"}",
		],
		"description": "Log output to console"
	},
	//sub - 高精度减法
	"sub - 高精度减法": {
		"prefix": "vector<int> sub",
		"body": [
			"vector<int> sub(vector<int> &A, vector<int> &B)  // C = A - B, 满足A >= B, A >= 0, B >= 0",
			"{",
			"\tvector<int> C;",
			"\tfor (int i = 0, t = 0; i < A.size(); i ++ )",
			"\t{",
			"\t\tt = A[i] - t;",
			"\t\tif (i < B.size()) t -= B[i];",
			"\t\tC.push_back((t + 10) % 10);",
			"\t\tif (t < 0) t = 1;",
			"\t\telse t = 0;",
			"\t}",
			"",
			"\twhile (C.size() > 1 && C.back() == 0) C.pop_back();",
			"\treturn C;",
			"}",
		],
		"description": "Log output to console"
	},
	//mul - 高精度乘低精度
	"mul - 高精度乘低精度": {
		"prefix": "vector<int> mul",
		"body": [
			"vector<int> mul(vector<int> &A, int b)  // C = A * b, A >= 0, b >= 0",
			"{",
			"\tvector<int> C;",
			"",
			"\tint t = 0;",
			"\tfor (int i = 0; i < A.size() || t; i ++ )",
			"\t{",
			"\t\tif (i < A.size()) t += A[i] * b;",
			"\t\tC.push_back(t % 10);",
			"\t\tt /= 10;",
			"\t}",
			"",
			"\twhile (C.size() > 1 && C.back() == 0) C.pop_back();",
			"",
			"\treturn C;",
			"}",
		],
		"description": "Log output to console"
	},
	//div - 高精度除以低精度
	"div - 高精度除以低精度": {
		"prefix": "vector<int> div",
		"body": [
			"vector<int> div(vector<int> &A, int b, int &r)  // A / b = C ... r, A >= 0, b > 0",
			"{",
			"\tvector<int> C;",
			"\tr = 0;",
			"\tfor (int i = A.size() - 1; i >= 0; i -- )",
			"\t{",
			"\t\tr = r * 10 + A[i];",
			"\t\tC.push_back(r / b);",
			"\t\tr %= b;",
			"\t}",
			"\treverse(C.begin(), C.end());",
			"\twhile (C.size() > 1 && C.back() == 0) C.pop_back();",
			"\treturn C;",
			"}",
		],
		"description": "Log output to console"
	},
	//欧拉筛质数
	"欧拉筛质数": {
		"prefix": "ola",
		"body": [
			"int st[N], primes[N], cnt;",
			"void ola(int n)",
			"{",
			"\tfor (int i = 2; i <= n; i++)",
			"\t{",
			"\t\tif (st[i] == 0)",
			"\t\t\tprimes[cnt++] = i;                   //将质数存到primes中",
			"\t\tfor (int j = 0; primes[j] <= n / i; j++) //要确保质数的第i倍是小于等于n的。",
			"\t\t{",
			"\t\t\tst[primes[j] * i] = 1;",
			"\t\t\tif (i % primes[j] == 0)",
			"\t\t\t\tbreak;",
			"\t\t}",
			"\t}",
			"}",
		],
		"description": "Log output to console"
	},
	//spfa判断是否有环
	"判断是否有环": {
		"prefix": "bool spfa",
		"body": [
			"bool spfa() {",
			"// 如果存在负环，则返回true，否则返回false。",
			"// 不需要初始化dist数组",
			"// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，",
			"// 由抽屉原理一定有两个点相同，所以存在环。",
			"\tint hh = 0, tt = 0;",
			"",
			"\tfor (int i = 1; i <= n; i ++ ) q[tt ++ ] = i, st[i] = true;",
			"",
			"\twhile (hh != tt)",
			"\t\t\t{",
			"\t\tint t = q[hh ++ ];",
			"\t\tif (hh == N) hh = 0;",
			"\t\tst[t] = false;",
			"",
			"\t\tfor (int i =  h[t]; ~i; i = ne[i])",
			"\t\t{",
			"\t\t\tint j = e[i];",
			"\t\t\tif (dist[j] > dist[t] + w[i])",
			"\t\t\t{",
			"\t\t\tdist[j] = dist[t]  + w[i];",
			"\t\t\t\tcnt[j] = cnt[t] + 1;",
			"\t\t\t\tif (cnt[j] >= n) return true;",
			"\t\t\t\tif (!st[j])",
			"\t\t\t\t{",
			"\t\t\t\t\tst[j] = true;",
			"\t\t\t\t\tq[tt ++ ] = j;",
			"\t\t\t\t\tif (tt == N) tt = 0;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"\treturn false;",
			"}",
		],
		"description": "Log output to console"
	},
	//tarjan算法求割点
	"tarjan割点": {
		"prefix": "tarjan",
		"body": [
			"//dfn(u)为节点u搜索的次序编号(时间戳),low(u)为u或u的子树能够追溯到的最早的栈中节点的次序号",
			"int dfn[N], low[N];",
			"int dindex;//dindex为时间戳",
			"int h[N], e[N * 2], ne[N * 2], idx;//邻接表存图",
			"int cut[N];",
			"int n, m;",
			"",
			"inline void add (int a, int b) {",
			"\te[idx] = b, ne[idx] = h[a], h[a] = idx++;",
			"}",
			"",
			"void tarjan (int u, int fa) {",
			"\tdfn[u] = low[u] = ++dindex;//初始都为时间戳",
			"\tint child=0;",
			"",
			"\tfor (int i = h[u];~i;i = ne[i]) {",
			"\t\tint j = e[i];",
			"\t\tif (!dfn[j]){",
			"\t\t\ttarjan(j, fa);",
			"\t\t\tlow[u] = min(low[u], low[j]);",
			"\t\t\tif (low[j] >= dfn[u] && u != fa)",
			"\t\t\t\tcut[u] = 1;",
			"\t\t\tif(u == fa)",
			"\t\t\t\tchild++;",
			"",
			"\t\t}",
			"\t\tlow[u] = min (low[u], dfn[j]);",
			"\t}",
			"\tif (child >= 2 && u== fa)",
			"\t\tcut[u] = 1;",
			"}",
			"",
			"void solve () {",
			"\tmemset (h, -1, sizeof h);",
			"\tmemset (dfn, 0, sizeof dfn);",
			"\tstop = bcnt = dindex = 0;",
			"",
			"\tn = read(), m = read();",
			"\tfor (int i = 1;i <= m;i ++) {",
			"\t\tint a =read(), b = read();",
			"\t\tadd(a, b);",
			"\t\tadd(b, a);",
			"\t}",
			"",
			"\tfor (int i = 1;i <= n;i ++) {",
			"\t\tif(!dfn[i]) tarjan(i, i);",
			"\t}",
			"}",
		],
		"description": "Log output to console"
	},
	//tarjan强连通分量
	"tarjan强连通分量": {
		"prefix": "tarjan",
		"body": [
			"int dfn[N], low[N], sta[N], gro[N], tot[N];",
			"bool instack[N];//是否在栈内",
			"int stop, bcnt, dindex;//stop栈内元素个数,bcnt为分组的组号,dindex为时间戳",
			"int h[N], e[N], ne[N], idx;//邻接表存图",
			"int n, m;",
			"",
			"inline void add (int a, int b) {",
			"\te[idx] = b, ne[idx] = h[a], h[a] = idx++;",
			"}",
			"",
			"void tarjan (int u) {",
			"\tdfn[u] = low[u] = ++dindex;//初始都为时间戳",
			"\tinstack[u] = true;//加入栈内",
			"\tsta[++stop] = u;",
			"\tfor (int i = h[u];~i;i = ne[i]) {",
			"\t\tint j = e[i];",
			"\t\tif (!dfn[j]){",
			"\t\t\ttarjan(j);",
			"\t\t\tif (low[j] < low[u]) low[u] = low[j];",
			"\t\t}else if (instack[j] && dfn[j] < low[u]) low[u] = dfn[j];",
			"\t}",
			"\tif (dfn[u] == low[u]) {",
			"\t\tbcnt++;",
			"\t\tint j;",
			"\t\tdo {",
			"\t\t\tj = sta[stop--];",
			"\t\t\tinstack[j] = false;",
			"\t\t\tgro[j] = bcnt;",
			"\t\t\ttot[bcnt]++;",
			"\t\t}while (j != u);",
			"\t}",
			"}",
			"",
			"void solve () {",
			"\tmemset (h, -1, sizeof h);",
			"\tmemset (dfn, 0, sizeof dfn);",
			"\tstop = bcnt = dindex = 0;",
			"",
			"\tn = read(), m = read();",
			"\tfor (int i = 1;i <= m;i ++) {",
			"\t\tint a =read(), b = read();",
			"\t\tadd(a, b);",
			"\t}",
			"",
			"\tfor (int i = 1;i <= n;i ++) {",
			"\t\tif(!dfn[i]) tarjan(i);",
			"\t}",
			"}"
		],
		"description": "Log output to console"
	},
	// "": {
	// 	"prefix": "log",
	// 	"body": [],
	// 	"description": "Log output to console"
	// },
	// "": {
	// 	"prefix": "log",
	// 	"body": [],
	// 	"description": "Log output to console"
	// },
	// "": {
	// 	"prefix": "log",
	// 	"body": [],
	// 	"description": "Log output to console"
	// },
}
```

